1、新建文件夹myBlog
2、打开文件夹内的命令行，运行npm init 安装 package.json
  package.json是基于nodejs项目必不可少的配置文件，它是存放在项目根目录的普通json文件重点内容，
  它是存放在项目根目录的普通json文件：
  -安装步骤：进入项目根目录打开此目录下的命令行--》npm init -->填写的内容参照下面链接内容
  （http://jingyan.baidu.com/article/14bd256e7f7d7fbb6d2612c4.html）
  ---name项不能包含大写字母 前四项是必填项 后边可填可不填
3、在myBlog文件夹下建立项目结构：
        ---public文件夹存放外部文件，images，js ，css ，，，存放静态文件，如样式、图片等
        ---views文件夹存放视图界面，，，存放模板文件
        ---routes文件夹存放路由，，，存放路由文件
        ---models文件夹存放，，，，存放操作数据库的文件
        ---app.js文件项目启动文件，，，程序主文件
        ---package.json: 存储项目名、描述、作者、依赖等等信息
        
        
---------我们遵循了 MVC（模型(model)－视图(view)－控制器(controller/route)） 的开发模式。        
        
4、安装依赖模块：        
    运行npm install 
    // node外部模块安装的具体方法和存放路径：
    // 安装命令：：npm install formidable
    // npm install在哪个目录下执行就安装在这个目录的node_modules文件夹下。
    // package.json定义了需要安装哪些依赖，在package.json所在的目录下执行npm install。
    此项目需要依赖的模块有：：：
      ----安装 Node 模块时，如果指定了 --save 参数，那么此模块将被添加到 package.json 文件中
      dependencies 依赖列表中。 
          然后通过 npm install 命令即可自动安装依赖列表中所列出的所有模块。
      --npm install config-lite connect-flash connect-mongo ejs express 
      express-formidable express-session marked moment mongolass objectid-to-timestamp
      sha1 winston express-winston --save
          
          
      config-lite: 读取配置文件
      connect-flash: 页面通知提示的中间件，基于 session 实现
      connect-mongo: 将 session 存储于 mongodb，结合 express-session 使用
      ejs: 模板
      express: web 框架
      express-formidable: 接收表单及文件的上传中间件
      express-session: session 中间件
      marked: markdown 解析
      moment: 时间格式化
      mongolass: mongodb 驱动
      objectid-to-timestamp: 根据 ObjectId 生成时间戳
      sha1: sha1 加密，用于密码加密
      winston: 日志
      express-winston: 基于 winston 的用于 express 的日志中间件
      
5、配置文件：：：
      不管是小项目还是大项目，将配置与代码分离是一个非常好的做法。我们通常将配置写到一个配置文件里，
      如 config（配置的意思）.js 或 config.json ，并放到项目的根目录下。但通常我们都会有许多环境，如本地开发环
      境、测试环境和线上环境等，不同的环境的配置不同，我们不可能每次部署时都要去修改引用 config.test.js 
      或者 config.production.js。config-lite 模块正是你需要的。
      config-lite 是一个轻量的读取配置文件的模块。config-lite 会根据环境变量（NODE_ENV）的不同从当前
      执行进程目录下的 config 目录加载不同的配置文件。如果不设置 NODE_ENV，则读取默认的 default 配置文件，
      如果设置了 NODE_ENV，则会合并指定的配置文件和 default 配置文件作为配置，config-lite 
      支持 .js、.json、.node、.yml、.yaml 后缀的文件。

      如果程序以 NODE_ENV=test node app 启动，则通过 require('config-lite') 会依次降级查找
      config/test.js、config/test.json、config/test.node、config/test.yml、config/test.yaml 
      并合并 default 配置; 如果程序以 NODE_ENV=production node app 启动，则通过 require('config-lite') 
      会依次降级查找 config/production.js、config/production.json、config/production.node、
      config/production.yml、config/production.yaml 并合并 default 配置。

      在 myblog 下新建 config 目录，在该目录下新建 default（默认的意思）.js，添加如下代码：

      config/default.js

      module.exports = {
        port: 3000,
        session: {
          secret: 'myblog',
          key: 'myblog',
          maxAge: 2592000000
        },
        mongodb: 'mongodb://localhost:27017/myblog'
      };
      配置释义：

      port: 程序启动要监听的端口号
      session: express-session 的配置信息，后面介绍
      mongodb: mongodb 的地址，myblog 为 db 名
      
      
 6、功能与路由设计

    在开发博客之前，我们首先需要明确博客要实现哪些功能。由于本教程面向初学者，所以只实现了博客最基本的功能，
    其余的功能（如归档、标签、分页等等）读者可自行实现。

    功能及路由设计如下：

    注册
    注册页：GET /signup
    注册（包含上传头像）：POST /signup
    
    登录
    登录页：GET /signin
    登录：POST /signin
    登出：GET /signout
    
    查看文章
    主页：GET /posts
    个人主页：GET /posts?author=xxx
    查看一篇文章（包含留言）：GET /posts/:postId
    发表文章
    发表文章页：GET /posts/create
    发表文章：POST /posts
    修改文章
    修改文章页：GET /posts/:postId/edit
    修改文章：POST /posts/:postId/edit
    删除文章：GET /posts/:postId/remove
    
    留言
    创建留言：POST /posts/:postId/comment
    删除留言：GET /posts/:postId/comment/:commentId/remove
    由于我们博客页面是后端渲染的，所以只通过简单的 <a>(GET) 和 <form>(POST) 与后端进行交互，
    如果使用 jQuery 或者其他前端框架（如 angular、vue、react 等等）可通过 Ajax 与后端交互，
    则 api 的设计应尽量遵循 restful 风格。 
       （ restful

            restful 是一种 api 的设计风格，提出了一组 api 的设计原则和约束条件。

            如上面删除文章的路由设计：

            GET /posts/:postId/remove
            restful 风格的设计：

            DELETE /post/:postId
            可以看出，restful 风格的 api 更直观且优雅。

            更多阅读：

            http://www.ruanyifeng.com/blog/2011/09/restful
            http://www.ruanyifeng.com/blog/2014/05/restful_api.html
            http://developer.51cto.com/art/200908/141825.htm
            http://blog.jobbole.com/41233/
        ）    
7、会话

      由于 HTTP 协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识别具体的用户，
      这个机制就是会话（Session）。关于 Session 的讲解网上有许多资料，这里不再赘述。参考：

      http://justsee.iteye.com/blog/1570652
      https://www.zhihu.com/question/19786827
      cookie 与 session 的区别

      cookie 存储在浏览器（有大小限制），session 存储在服务端（没有大小限制）
      通常 session 的实现是基于 cookie 的，即 session id 存储于 cookie 中
      我们通过引入 express-session 中间件实现对会话的支持：

      app.use(session(options))
      session 中间件会在 req 上添加 session 对象，即 req.session 初始值为 {}，当我们登录后设置 
      req.session.user = 用户信息，返回浏览器的头信息中会带上 set-cookie 将 session id 写到
      浏览器 cookie 中，那么该用户下次请求时，通过带上来的 cookie 中的 session id 我们就可以查找
      到该用户，并将用户信息保存到 req.session.user。
      
8、页面通知

    我们还需要这样一个功能：当我们操作成功时需要显示一个成功的通知，如登录成功跳转到主页时，需要显示一个 
    登陆成功 的通知；当我们操作失败时需要显示一个失败的通知，如注册时用户名被占用了，需要显示一个 
    用户名已占用 的通知。通知只显示一次，刷新后消失，我们可以通过 connect-flash 中间件实现这个功能。

    connect-flash 是基于 session 实现的，它的原理很简单：设置初始值 req.session.flash={}，通过 
    req.flash(name, value) 设置这个对象下的字段和值，通过 req.flash(name) 获取这个对象下的值，同时删除这个字段。

    express-session、connect-mongo 和 connect-flash 的区别与联系

    express-session: 会话（session）支持中间件
    connect-mongo: 将 session 存储于 mongodb，需结合 express-session 使用，我们也可以将 session 存储于 redis，如 connect-redis
    connect-flash: 基于 session 实现的用于通知功能的中间件，需结合 express-session 使用     

9、权限控制

    不管是论坛还是博客网站，我们没有登录的话只能浏览，登陆后才能发帖或写文章，即使登录了你也不能修改或删除其他人的文章，
    这就是权限控制。我们也来给博客添加权限控制，如何实现页面的权限控制呢？我们可以把用户状态的检查封装成一个中间件，
    在每个需要权限控制的路由加载该中间件，即可实现页面的权限控制。在 myblog 下新建 middlewares 文件夹，
    在该目录下新建 check.js，添加如下代码：

    middlewares/check.js

    module.exports = {
      checkLogin: function checkLogin(req, res, next) {
        if (!req.session.user) {
          req.flash('error', '未登录'); 
          return res.redirect('/signin');
        }
        next();
      },

      checkNotLogin: function checkNotLogin(req, res, next) {
        if (req.session.user) {
          req.flash('error', '已登录'); 
          return res.redirect('back');//返回之前的页面
        }
        next();
      }
    };
    
    ----------------------------------------------------------------------------------------------------------------------
    Express是一个基于Node.js实现的Web框架，其响应HTTP请求的response对象中有两个
    用于URL跳转方法res.location()和res.redirect()，使用它们可以实现URL的301或302重定向。
    res.redirect([status,] path)
    其中参数：
    status：{Number}，表示要设置的HTTP状态码
    path：{String}，要设置到Location头中的URL
    使用指定的http状态码，重定向到指定的URL，如果不指定http状态码，使用默认的状态码”302“：”Found“，
    详见：：：http://www.cnblogs.com/duhuo/p/5609127.html
    
    ------------------------------------------------------------------------------------------------------------------------
    
    
    可以看出：

    checkLogin: 当用户信息（req.session.user）不存在，即认为用户没有登录，则跳转到登录页，同时显示 未登录 的通知，
    用于需要用户登录才能操作的页面及接口checkNotLogin: 当用户信息（req.session.user）存在，即认为用户已经登录，
    则跳转到之前的页面，同时显示 已登录 的通知，如登录、注册页面及登录、注册的接口
    最终我们创建以下路由文件：

    routes/index.js

    module.exports = function (app) {
      app.get('/', function (req, res) {
        res.redirect('/posts');
      });
      app.use('/signup', require('./signup'));
      app.use('/signin', require('./signin'));
      app.use('/signout', require('./signout'));
      app.use('/posts', require('./posts'));
    };
    
    
    -----------------------------------------------------------------------------------------------------------------
          app.use 不是来处理请求的, 而是来加载处理请求的路由模块的参数.
      比如这个例子:
          app.use(express.bodyParser());
          app.use(express.methodOverride());
          app.use(app.router);
          app.use(function(err, req, res, next){
            // logic
          });
          一个请求过来, 被 .use 写好的各个函数依次处理,
          更准确说, 是从第一个开始处理, 到一个做一点操作, 也可能截断流程直接返回…
          而 app.get 等等 HTTP 请求的操作, 统一在 app.routes 着一个模块里边
          http://expressjs.com/api.html#app.routes
          所以, 先调用应该是 app.use, 而 app.get 应该是属于被前者调用才对…

          app.use和app.get,app.post等等在express框架里面处理都是类似的,都是抽象成一个Layer(层),
          只是app.get这些的层比app.use的层稍微复杂一点.顺序方面的话,先注册的层在访问的时候先调用,
          调用next()到下一个匹配url的Layer
          
          express 中的中间件（middleware）就是用来处理请求的，当一个中间件处理完，可以通过调用 next() 
          传递给下一个中间件，如果没有调用 next()，则请求不会往下传递
          
          通过 app.use 加载中间件，在中间件中通过 next 将请求传递到下一个中间件
          ，next 可接受一个参数接收错误信息，如果使用了 next(error)，则会返回错误而不会传递到下一个中间件，
          app.get（）是他的一个特殊形式或是子集，只能用来处理http请求，
          执行顺序是先调用先执行属于平级，express 中的中间件（middleware）就是用来处理请求的，当一个中间件处理完，
          可以通过调用 next()传递给下一个中间件，如果没有调用 next()，则请求不会往下传递
    -----------------------------------------------------------------------------------------------------------------
    
    ----------------------------------------------------------------------------------------------------------------
    
    require 用来加载一个文件的代码，关于 require 的机制这里不展开讲解，请仔细阅读 官方文档。
    简单概括以下几点:
    require 可加载 .js、.json 和 .node 后缀的文件
    require 的过程是同步的，所以这样是错误的:
    setTimeout(() => {
      module.exports = { a: 'hello' };
    }, 0);
    require 这个文件得到的是空对象 {}

    require 目录的机制是:
    如果目录下有 package.json 并指定了 main 字段，则用之
    如果不存在 package.json，则依次尝试加载目录下的 index.js 和 index.node
    require 过的文件会加载到缓存，所以多次 require 同一个文件（模块）不会重复加载
    判断是否是程序的入口文件有两种方式:
    require.main === module（推荐）
    module.parent === null
    
    -----------------------------------------------------------------------------------------------------------------------
    
    routes/posts.js

    var express = require('express');
    var router = express.Router();

    var checkLogin = require('../middlewares/check').checkLogin;

    // GET /posts 所有用户或者特定用户的文章页
    //   eg: GET /posts?author=xxx
    router.get('/', function(req, res, next) {
      res.send(req.flash());
    });
    
     --------------------------------------------------------------------------------------------------------
     
     res.send（）：发送一个响应。
     
     -----------------------------------------------------------------------------------------------------------
    
    // POST /posts 发表一篇文章
    router.post('/', checkLogin, function(req, res, next) {
      res.send(req.flash());
    });

    // GET /posts/create 发表文章页
    router.get('/create', checkLogin, function(req, res, next) {
      res.send(req.flash());
    });

    // GET /posts/:postId 单独一篇的文章页
    router.get('/:postId', function(req, res, next) {
      res.send(req.flash());
    });

    // GET /posts/:postId/edit 更新文章页
    router.get('/:postId/edit', checkLogin, function(req, res, next) {
      res.send(req.flash());
    });

    // POST /posts/:postId/edit 更新一篇文章
    router.post('/:postId/edit', checkLogin, function(req, res, next) {
      res.send(req.flash());
    });

    // GET /posts/:postId/remove 删除一篇文章
    router.get('/:postId/remove', checkLogin, function(req, res, next) {
      res.send(req.flash());
    });

    // POST /posts/:postId/comment 创建一条留言
    router.post('/:postId/comment', checkLogin, function(req, res, next) {
      res.send(req.flash());
    });

    // GET /posts/:postId/comment/:commentId/remove 删除一条留言
    router.get('/:postId/comment/:commentId/remove', checkLogin, function(req, res, next) {
      res.send(req.flash());
    });

    module.exports = router;
    routes/signin.js

    var express = require('express');
    var router = express.Router();

    var checkNotLogin = require('../middlewares/check').checkNotLogin;

    // GET /signin 登录页
    router.get('/', checkNotLogin, function(req, res, next) {
      res.send(req.flash());
    });

    // POST /signin 用户登录
    router.post('/', checkNotLogin, function(req, res, next) {
      res.send(req.flash());
    });

    module.exports = router;
    routes/signup.js

    var express = require('express');
    var router = express.Router();

    var checkNotLogin = require('../middlewares/check').checkNotLogin;

    // GET /signup 注册页
    router.get('/', checkNotLogin, function(req, res, next) {
      res.send(req.flash());
    });

    // POST /signup 用户注册
    router.post('/', checkNotLogin, function(req, res, next) {
      res.send(req.flash());
    });

    module.exports = router;
    routes/signout.js

    var express = require('express');
    var router = express.Router();

    var checkLogin = require('../middlewares/check').checkLogin;

    // GET /signout 登出
    router.get('/', checkLogin, function(req, res, next) {
      res.send(req.flash());
    });

    module.exports = router;
    最后， 修改 index.js 如下：

    index.js

    var path = require('path');
    var express = require('express');
    var session = require('express-session');
    var MongoStore = require('connect-mongo')(session);
    var flash = require('connect-flash');
    var config = require('config-lite');
    var routes = require('./routes');
    var pkg = require('./package');

    var app = express();

    // 设置模板目录
    app.set('views', path.join(__dirname, 'views'));
    // 设置模板引擎为 ejs
    app.set('view engine', 'ejs');

    // 设置静态文件目录
    app.use(express.static(path.join(__dirname, 'public')));
    // session 中间件
    app.use(session({
      name: config.session.key,// 设置 cookie 中保存 session id 的字段名称
      secret: config.session.secret,// 通过设置 secret 来计算 hash 值并放在 cookie 中，使产生的 signedCookie 防篡改
      cookie: {
        maxAge: config.session.maxAge// 过期时间，过期后 cookie 中的 session id 自动删除
      },
      store: new MongoStore({// 将 session 存储到 mongodb
        url: config.mongodb// mongodb 地址
      })
    }));
    // flash 中间件，用来显示通知
    app.use(flash());

    // 路由
    routes(app);

    // 监听端口，启动程序
    app.listen(config.port, function () {
      console.log(`${pkg.name} listening on port ${config.port}`);
    });
    注意：中间件的加载顺序很重要。如上面设置静态文件目录的中间件应该放到 routes(app) 之前加载，
    这样静态文件的请求就不会落到业务逻辑的路由里；flash 中间件应该放到 session 中间件之后加载，因为 flash 是基于 session 的。
    运行 supervisor --harmony index 启动博客，访问以下地址查看效果：

    http://localhost:3000/posts
    http://localhost:3000/signout
    http://localhost:3000/signup


 10、页面设计
 我们使用 jQuery + Semantic-UI 实现前端页面的设计，最终效果图如下:
 http://www.semantic-ui.cn/
 11、组件
 前面提到过，我们可以将模板拆分成一些组件，然后使用 ejs 的 include 方法将组件组合起来进行渲染。我们将页面切分成以下组件：
 根据上面的组件切分图，我们创建以下样式及模板文件：

    public/css/style.css

    /* ---------- 全局样式 ---------- */

    body {
      width: 1100px;
      height: 100%;
      margin: 0 auto;
      padding-top: 40px;
    }

    a:hover {
      border-bottom: 3px solid #4fc08d;
    }

    .button {
      background-color: #4fc08d !important;
      color: #fff !important;
    }

    .avatar {
      border-radius: 3px;
      width: 48px;
      height: 48px;
      float: right;
    }

    /* ---------- nav ---------- */

    .nav {
      margin-bottom: 20px;
      color: #999;
      text-align: center;
    }

    .nav h1 {
      color: #4fc08d;
      display: inline-block;
      margin: 10px 0;
    }

    /* ---------- nav-setting ---------- */

    .nav-setting {
      position: fixed;
      right: 30px;
      top: 35px;
      z-index: 999;
    }

    .nav-setting .ui.dropdown.button {
      padding: 10px 10px 0 10px;
      background-color: #fff !important;
    }

    .nav-setting .icon.bars {
      color: #000;
      font-size: 18px;
    }

    /* ---------- post-content ---------- */

    .post-content h3 a {
      color: #4fc08d !important;
    }

    .post-content .tag {
      font-size: 13px;
      margin-right: 5px;
      color: #999;
    }

    .post-content .tag.right {
      float: right;
      margin-right: 0;
    }

    .post-content .tag.right a {
      color: #999;
    }
    views/header.ejs

    <!DOCTYPE html>
    <html>
      <head>
        <meta charset="utf-8">
        <title><%= blog.title %></title>
        <link rel="stylesheet" href="//cdn.bootcss.com/semantic-ui/2.1.8/semantic.min.css">
        <link rel="stylesheet" href="/css/style.css">
        <script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script>
        <script src="//cdn.bootcss.com/semantic-ui/2.1.8/semantic.min.js"></script>
      </head>
      <body>
      <%- include('components/nav') %>
      <%- include('components/nav-setting') %>
      <%- include('components/notification') %>
    views/footer.ejs

      <script type="text/javascript">
        // 点击按钮弹出下拉框
        $('.ui.dropdown').dropdown();
        // 鼠标悬浮在头像上，弹出气泡提示框
        $('.post-content .avatar').popup({
          inline: true,
          position: 'bottom right',
          lastResort: 'bottom right',
        });
      </script>
      </body>
    </html>
    注意：上面 <script></script> 是 semantic-ui 操控页面控件的代码，一定要放到 footer.ejs 的 </body> 的前面，
    因为只有页面加载完后才能通过 JQuery 获取 DOM 元素。
    在 views 目录下新建 components 目录用来存放组件，在该目录下创建以下文件：

    views/components/nav.ejs

    <div class="nav">
      <div class="ui grid">
        <div class="four wide column"></div>

        <div class="eight wide column">
          <a href="/posts"><h1><%= blog.title %></h1></a>
          <p><%= blog.description %></p>
        </div>
      </div>
    </div>
    views/components/nav-setting.ejs

    <div class="nav-setting">
      <div class="ui buttons">
        <div class="ui floating dropdown button">
          <i class="icon bars"></i>
          <div class="menu">
            <% if (user) { %>
              <a class="item" href="/posts?author=<%= user._id %>">个人主页</a>
              <div class="divider"></div>
              <a class="item" href="/posts/create">发表文章</a>
              <a class="item" href="/signout">登出</a>
            <% } else { %>
              <a class="item" href="/signin">登录</a>
              <a class="item" href="/signup">注册</a>
            <% } %>
          </div>
        </div>
      </div>
    </div>
    views/components/notification.ejs

    <div class="ui grid">
      <div class="four wide column"></div>
      <div class="eight wide column">

      <% if (success) { %>
        <div class="ui success message">
          <p><%= success %></p>
        </div>
      <% } %>

      <% if (error) { %>
        <div class="ui error message">
          <p><%= error %></p>
        </div>
      <% } %>

      </div>
    </div>
    4.5.2 app.locals 和 res.locals

    上面的模板中我们用到了 blog、user、success、error 变量，我们将 blog 变量挂载到 app.locals 下，
    将 user、success、error 挂载到 res.locals 下。为什么要这么做呢？app.locals 和 res.locals 是什么？它们有什么区别？

    express 中有两个对象可用于模板的渲染：app.locals 和 res.locals。我们从 express 源码一探究竟：

    express/lib/application.js

    app.render = function render(name, options, callback) {
      ...
      var opts = options;
      var renderOptions = {};
      ...
      // merge app.locals
      merge(renderOptions, this.locals);

      // merge options._locals
      if (opts._locals) {
        merge(renderOptions, opts._locals);
      }

      // merge options
      merge(renderOptions, opts);
      ...
      tryRender(view, renderOptions, done);
    };
    express/lib/response.js

    res.render = function render(view, options, callback) {
      var app = this.req.app;
      var opts = options || {};
      ...
      // merge res.locals
      opts._locals = self.locals;
      ...
      // render
      app.render(view, opts, done);
    };
    可以看出：在调用 res.render 的时候，express 合并（merge）了 3 处的结果后传入要渲染的模板，
    优先级：res.render 传入的对象> res.locals 对象 > app.locals 对象，所以 app.locals 和 res.locals 几乎没有区别，
    都用来渲染模板，使用上的区别在于：app.locals 上通常挂载常量信息（如博客名、描述、作者信息），res.locals 
    上通常挂载变量信息，即每次请求可能的值都不一样（如请求者信息，res.locals.user = req.session.user）。

    修改 index.js，在 routes(app); 上一行添加如下代码：

    // 设置模板全局常量
    app.locals.blog = {
      title: pkg.name,
      description: pkg.description
    };

    // 添加模板必需的三个变量
    app.use(function (req, res, next) {
      res.locals.user = req.session.user;
      res.locals.success = req.flash('success').toString();
      res.locals.error = req.flash('error').toString();
      next();
    });
    这样在调用 res.render 的时候就不用传入这四个变量了，express 为我们自动 merge 并传入了模板，
    所以我们可以在模板中直接使用这四个变量。
    
    12、数据库连接
    我们使用 Mongolass 这个模块操作 mongodb 进行增删改查。在 myblog 下新建 lib 目录，在该目录下新建 mongo.js，添加如下代码：

    lib/mongo.js

    var config = require('config-lite');
    var Mongolass = require('mongolass');
    var mongolass = new Mongolass();
    mongolass.connect(config.mongodb);
    4.7.1 用户模型设计

    我们只存储用户的名称、密码（加密后的）、头像、性别和个人简介这几个字段，对应修改 lib/mongo.js，添加如下代码：

    lib/mongo.js

    exports.User = mongolass.model('User', {
      name: { type: 'string' },
      password: { type: 'string' },
      avatar: { type: 'string' },
      gender: { type: 'string', enum: ['m', 'f', 'x'] },
      bio: { type: 'string' }
    });
    exports.User.index({ name: 1 }, { unique: true }).exec();// 根据用户名找到用户，用户名全局唯一
    我们定义了用户表的 schema，生成并导出了 User 这个 model，同时设置了 name 的唯一索引，保证用户名是不重复的。

    小提示：关于 Mongolass 的 schema 的用法，请查阅 another-json-schema。

    小提示：Mongolass 中的 model 你可以认为相当于 mongodb 中的 collection，只不过添加了插件的功能
    
    
    13、注册页

    首先，我们来完成注册。新建 views/signup.ejs，添加如下代码：

    views/signup.ejs

    <%- include('header') %>

    <div class="ui grid">
      <div class="four wide column"></div>
      <div class="eight wide column">
        <form class="ui form segment" method="post" enctype="multipart/form-data">
          <div class="field required">
            <label>用户名</label>
            <input placeholder="用户名" type="text" name="name">
          </div>
          <div class="field required">
            <label>密码</label>
            <input placeholder="密码" type="password" name="password">
          </div>
          <div class="field required">
            <label>重复密码</label>
            <input placeholder="重复密码" type="password" name="repassword">
          </div>
          <div class="field required">
            <label>性别</label>
            <select class="ui compact selection dropdown" name="gender">
              <option value="m">男</option>
              <option value="f">女</option>
              <option value="x">保密</option>
            </select>
          </div>
          <div class="field required">
            <label>头像</label>
            <input type="file" name="avatar">
          </div>
          <div class="field required">
            <label>个人简介</label>
            <textarea name="bio" rows="5" v-model="user.bio"></textarea>
          </div>
          <input type="submit" class="ui button fluid" value="注册">
        </div>
      </form>
    </div>

    <%- include('footer') %>
    注意：form 表单要添加 enctype="multipart/form-data" 属性才能上传文件。
    修改 routes/signup.js 中获取注册页的路由如下：

    routes/signup.js

    // GET /signup 注册页
    router.get('/', checkNotLogin, function(req, res, next) {
      res.render('signup');
    });
    现在访问 localhost:3000/signup 看看效果吧。
    
    注册与文件上传

    我们使用 express-formidable 处理 form 表单（包括文件上传）。修改 index.js ，在 app.use(flash()); 下一行添加如下代码：

    index.js

    // 处理表单及文件上传的中间件
    app.use(require('express-formidable')({
      uploadDir: path.join(__dirname, 'public/img'),// 上传文件目录
      keepExtensions: true// 保留后缀
    }));
    新建 models/users.js，添加如下代码：

    models/users.js

    var User = require('../lib/mongo').User;

    module.exports = {
      // 注册一个用户
      create: function create(user) {
        return User.create(user).exec();
      }
    };
    完善处理用户注册的路由，最终修改 routes/signup.js 如下：

    routes/signup.js

    var fs = require('fs');
    var path = require('path');
    var sha1 = require('sha1');
    var express = require('express');
    var router = express.Router();

    var UserModel = require('../models/users');
    var checkNotLogin = require('../middlewares/check').checkNotLogin;

    // GET /signup 注册页
    router.get('/', checkNotLogin, function(req, res, next) {
      res.render('signup');
    });

    // POST /signup 用户注册
    router.post('/', checkNotLogin, function(req, res, next) {
      var name = req.fields.name;
      var gender = req.fields.gender;
      var bio = req.fields.bio;
      var avatar = req.files.avatar.path.split(path.sep).pop();
      var password = req.fields.password;
      var repassword = req.fields.repassword;

      // 校验参数
      try {
        if (!(name.length >= 1 && name.length <= 10)) {
          throw new Error('名字请限制在 1-10 个字符');
        }
        if (['m', 'f', 'x'].indexOf(gender) === -1) {
          throw new Error('性别只能是 m、f 或 x');
        }
        if (!(bio.length >= 1 && bio.length <= 30)) {
          throw new Error('个人简介请限制在 1-30 个字符');
        }
        if (!req.files.avatar.name) {
          throw new Error('缺少头像');
        }
        if (password.length < 6) {
          throw new Error('密码至少 6 个字符');
        }
        if (password !== repassword) {
          throw new Error('两次输入密码不一致');
        }
      } catch (e) {
        // 注册失败，异步删除上传的头像
        fs.unlink(req.files.avatar.path);
        req.flash('error', e.message);
        return res.redirect('/signup');
      }

      // 明文密码加密
      password = sha1(password);

      // 待写入数据库的用户信息
      var user = {
        name: name,
        password: password,
        gender: gender,
        bio: bio,
        avatar: avatar
      };
      // 用户信息写入数据库
      UserModel.create(user)
        .then(function (result) {
          // 此 user 是插入 mongodb 后的值，包含 _id
          user = result.ops[0];
          // 将用户信息存入 session
          delete user.password;
          req.session.user = user;
          // 写入 flash
          req.flash('success', '注册成功');
          // 跳转到首页
          res.redirect('/posts');
        })
        .catch(function (e) {
          // 注册失败，异步删除上传的头像
          fs.unlink(req.files.avatar.path);
          // 用户名被占用则跳回注册页，而不是错误页
          if (e.message.match('E11000 duplicate key')) {
            req.flash('error', '用户名已被占用');
            return res.redirect('/signup');
          }
          next(e);
        });
    });

    module.exports = router;
    注意：我们使用 sha1 加密用户的密码，sha1 并不是一种十分安全的加密方式，实际开发中可以使用更安全的 bcrypt 或 scrypt 加密。
    注意：注册失败时（参数校验失败或者存数据库时出错）删除已经上传到 public/img 目录下的头像。
    为了方便观察效果，我们先创建主页的模板。修改 routes/posts.js 中对应代码如下：

    routes/posts.js

    router.get('/', function(req, res, next) {
      res.render('posts');
    });
    新建 views/posts.ejs，添加如下代码：

    views/posts.ejs

    <%- include('header') %>
    这是主页
    <%- include('footer') %>
    访问 localhost:3000/signup，注册成功后如下所示：
    
    登出

    现在我们来完成登出的功能。修改 routes/signout.js 如下：

    routes/signout.js

    var express = require('express');
    var router = express.Router();

    var checkLogin = require('../middlewares/check').checkLogin;

    // GET /signout 登出
    router.get('/', checkLogin, function(req, res, next) {
      // 清空 session 中用户信息
      req.session.user = null;
      req.flash('success', '登出成功');
      // 登出成功后跳转到主页
      res.redirect('/posts');
    });

    module.exports = router;
    
    
    登录页

    现在我们来完成登录页。修改 routes/signin.js 相应代码如下：

    routes/signin.js

    router.get('/', checkNotLogin, function(req, res, next) {
      res.render('signin');
    });
    新建 views/signin.ejs，添加如下代码：

    views/signin.ejs
    
    
    现在我们来完成登录的功能。修改 models/users.js 添加 getUserByName 方法用于通过用户名获取用户信息：

    models/users.js

    var User = require('../lib/mongo').User;

    module.exports = {
      // 注册一个用户
      create: function create(user) {
        return User.create(user).exec();
      },

      // 通过用户名获取用户信息
      getUserByName: function getUserByName(name) {
        return User
          .findOne({ name: name })
          .addCreatedAt()
          .exec();
      }
    };
    这里我们使用了 addCreatedAt 自定义插件（通过 _id 生成时间戳），修改 lib/mongo.js，添加如下代码：

    lib/mongo.js

    var moment = require('moment');
    var objectIdToTimestamp = require('objectid-to-timestamp');

    // 根据 id 生成创建时间 created_at
    mongolass.plugin('addCreatedAt', {
      afterFind: function (results) {
        results.forEach(function (item) {
          item.created_at = moment(objectIdToTimestamp(item._id)).format('YYYY-MM-DD HH:mm');
        });
        return results;
      },
      afterFindOne: function (result) {
        if (result) {
          result.created_at = moment(objectIdToTimestamp(result._id)).format('YYYY-MM-DD HH:mm');
        }
        return result;
      }
    });
    小提示：24 位长的 ObjectId 前 4 个字节是精确到秒的时间戳，所以我们没有额外的存创建时间（如: createdAt）的字段。ObjectId 生成规则：


    修改 routes/signin.js 如下：

    routes/signin.js

    var sha1 = require('sha1');
    var express = require('express');
    var router = express.Router();

    var UserModel = require('../models/users');
    var checkNotLogin = require('../middlewares/check').checkNotLogin;

    // GET /signin 登录页
    router.get('/', checkNotLogin, function(req, res, next) {
      res.render('signin');
    });

    // POST /signin 用户登录
    router.post('/', checkNotLogin, function(req, res, next) {
      var name = req.fields.name;
      var password = req.fields.password;

      UserModel.getUserByName(name)
        .then(function (user) {
          if (!user) {
            req.flash('error', '用户不存在');
            return res.redirect('back');
          }
          // 检查密码是否匹配
          if (sha1(password) !== user.password) {
            req.flash('error', '用户名或密码错误');
            return res.redirect('back');
          }
          req.flash('success', '登录成功');
          // 用户信息写入 session
          delete user.password;
          req.session.user = user;
          // 跳转到主页
          res.redirect('/posts');
        })
        .catch(next);
    });

    module.exports = router;
    现在访问 localhost:3000/signin，用刚才注册的账号登录，如下图所示：

        <%- include('header') %>

        <div class="ui grid">
          <div class="four wide column"></div>
          <div class="eight wide column">
            <form class="ui form segment" method="post">
              <div class="field required">
                <label>用户名</label>
                <input placeholder="用户名" type="text" name="name">
              </div>
              <div class="field required">
                <label>密码</label>
                <input placeholder="密码" type="password" name="password">
              </div>
              <input type="submit" class="ui button fluid" value="登录">
            </form>  
          </div>
        </div>

        <%- include('footer') %>
        现在访问 localhost:3000/signin 试试吧。

