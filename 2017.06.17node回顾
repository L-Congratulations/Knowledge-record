对于写在HTML页面里的JS，浏览器充当了解析器的角色。而对于需要独立运行的JS，NodeJS就是一个解析器。
例如运行在浏览器中的JS的用途是操作DOM，浏览器就提供了document之类的内置对象。
而运行在NodeJS中的JS的用途是操作磁盘文件或搭建HTTP服务器，NodeJS就相应提供了fs、http等内置对象。


一、node安装
  1.1、node安装：直接去官网下载https://nodejs.org/en/download/，选择合适的版本进行安装
  1.2、检测PATH环境变量是否配置了Node.js，点击开始=》运行=》输入"cmd" => 输入命令"path"，输出如下结果：。。。
      如果我们可以看到环境变量中已经包含了C:\Program Files\nodejs\就说明安装配置成功
  1.3、打开命令行输入指令node运行会发现命令行左上角会有-node字符，说明现在进入到了node运行环境输入console.log("第一条命令")，这只是用node运行简单
    的命令。如果想同时运行多行命令？--可以直接运行一个js文件，因为js文件里面是不限制命令多少的。具体方法，找到js所在的文件目录，运行node hello如下
    D:\environment\web APP\node_huigulianxi\first>node hello（hello.js中只有一条命令console.log("第一个node命令")
    第一个node命令
  1.4、npm使用
    允许用户从NPM服务器下载别人编写的第三方包到本地使用。
    允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。
    允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。
    npm 的包安装分为本地安装（local）、全局安装（global）两种，从敲的命令行来看，差别只是有没有-g而已，比如
    npm install express          # 本地安装
    npm install express -g   # 全局安装
    
    本地安装
    1. 将安装包放在 ./node_modules 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成
    node_modules 目录。
    2. 可以通过 require() 来引入本地安装的包。
    全局安装
    1. 将安装包放在 /usr/local 下或者你 node 的安装目录。
    2. 可以直接在命令行里使用。
  1.4、编写稍大一点的程序的时候一般都会讲代码模块化，在NodeJS中，一般将代码合理拆分到不同的JS文件中，每一个文件就是一个模块，而文件路径就是模块名。
  1.5、在编写每个模块时，都有require、exports、module三个预先定义好的变量可供使用。
  
      require:
          require函数用于在当前模块中加载和使用别的模块，传入一个模块名，返回一个模块导出对象。模块名可使用相对路径（以./开头），
          或者是绝对路径（以/或C:之类的盘符开头）。另外，模块名中的.js扩展名可以省略。以下是一个例子。

          var foo1 = require('./foo');
          var foo2 = require('./foo.js');
          var foo3 = require('/home/user/foo');
          var foo4 = require('/home/user/foo.js');
          // foo1至foo4中保存的是同一个模块的导出对象。
          另外，可以使用以下方式加载和使用一个JSON文件。
          var data = require('./data.json');
          
      exports:
          exports对象是当前模块的导出对象，用于导出模块公有方法和属性。别的模块通过require函数使用当前模块时得到的就是当前模块的exports对象。
          以下例子中导出了一个公有方法。

          exports.hello = function () {
              console.log('Hello World!');
          };  
      module:
          通过module对象可以访问到当前模块的一些相关信息，但最多的用途是替换当前模块的导出对象。例如模块导出对象默认是一个普通对象，
          如果想改成一个函数的话，可以使用以下方式。

          module.exports = function () {
              console.log('Hello World!');
          };
          以上代码中，模块默认导出对象被替换为一个函数。    
          ------------------------------------------------------------------------------------------------------------------------
          注意：一个模块中的JS代码仅在模块第一次被使用时执行一次，并在执行过程中初始化模块的导出对象。之后，缓存起来的导出对象被重复利用。
          var counter1 = require('./util/counter');
          var    counter2 = require('./util/counter');

          console.log(counter1.count());
          console.log(counter2.count());
          console.log(counter2.count());
          运行该程序的结果如下：

          $ node main.js
          1
          2
          3
          可以看到，counter.js并没有因为被require了两次而初始化两次。
          --------------------------------------------------------------------------------------------------------------------------

二、express安装
  2.1、
三、node服务器搭建
  3.1、事件驱动的异步服务器端JavaScript和它的回调。
    当我们使用 http.createServer 方法的时候，我们当然不只是想要一个侦听某个端口的服务器，我们还想要它在服务器收到一个HTTP请求的时候做点什么。
    问题是，这是异步的：请求任何时候都可能到达，但是我们的服务器却跑在一个单进程中。
    那么在我们的Node.js程序中，当一个新的请求到达8888端口的时候，我们怎么控制流程呢？嗯，这就是Node.js/JavaScript的事件驱动设计能够真正帮上
    忙的地方了
    我们创建了服务器，并且向创建它的方法传递了一个函数。无论何时我们的服务器收到一个请求，这个函数就会被调用。
    我们不知道这件事情什么时候会发生，但是我们现在有了一个处理请求的地方：它就是我们传递过去的那个函数。至于它是被预先定义的函数还是匿名函数，
    就无关紧要了。这个就是传说中的 回调 。我们给某个方法传递了一个函数，这个方法在有相应事件发生时调用这个函数来进行 回调 。
    
    var http = require("http");

    function onRequest(request, response){
      console.log("Request received.");
      response.writeHead(200,{"Content-Type":"text/plain"});
      response.write("Hello World");
      response.end();
    }
    http.createServer(onRequest).listen(8888);
    console.log("Server has started.");
    注意：在 onRequest （我们的回调函数）触发的地方，我用 console.log 输出了一段文本。在HTTP服务器开始工作之后，也输出一段文本。
    当我们与往常一样，运行它node server.js时，它会马上在命令行上输出“Server has started.”。当我们向服务器发出请求
    （在浏览器访问http://localhost:8888/ ），“Request received.”这条消息就会在命令行中出现。
    这就是事件驱动的异步服务器端JavaScript和它的回调啦！
    （请注意，当我们在服务器访问网页时，我们的服务器可能会输出两次“Request received.”。那是因为大部分服务器都会在你访问 http://localhost:8888 /
    时尝试读取 http://localhost:8888/favicon.ico )
  3.2、服务器是如何处理请求的
    我们的 onRequest() 函数被触发的时候，有两个参数被传入： request 和 response 。
    它们是对象，你可以使用它们的方法来处理HTTP请求的细节，并且响应请求（比如向发出请求的浏览器发回一些东西）。
    最后，我们调用 response.end() 完成响应。
  3.3、模块化处理
    目前，我们的HTTP服务器需要导出的功能非常简单，因为请求服务器模块的脚本仅仅是需要启动服务器而已。
    我们把我们的服务器脚本放到一个叫做 start 的函数里，然后我们会导出这个函数。
    var http = require("http");
    function start(){
      function onRequest(request, response){
        console.log("Request received.");
        response.writeHead(200,{"Content-Type":"text/plain"});
        response.write("Hello World");
        response.end();
      }
      http.createServer(onRequest).listen(8888);
      console.log("Server has started.");
    }
    exports.start = start;
    创建 index.js 文件并写入以下内容：
    var server = require("./server");
    server.start();
    正如你所看到的，我们可以像使用任何其他的内置模块一样使用server模块：请求这个文件并把它指向一个变量，其中已导出的函数就可以被我们使用了。
    这样，我们现在就可以创建我们的主文件 index.js 并在其中启动我们的HTTP了，虽然服务器的代码还在 server.js 中。
  3.4、请求路由处理
    处理不同的HTTP请求在我们的代码中是一个不同的部分，叫做“路由选择”——那么，我们接下来就创造一个叫做 路由 的模块吧。
    
四、restful风格服务器搭建
