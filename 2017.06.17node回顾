对于写在HTML页面里的JS，浏览器充当了解析器的角色。而对于需要独立运行的JS，NodeJS就是一个解析器。
例如运行在浏览器中的JS的用途是操作DOM，浏览器就提供了document之类的内置对象。
而运行在NodeJS中的JS的用途是操作磁盘文件或搭建HTTP服务器，NodeJS就相应提供了fs、http等内置对象。


一、node安装
  1.1、node安装：直接去官网下载https://nodejs.org/en/download/，选择合适的版本进行安装
  1.2、检测PATH环境变量是否配置了Node.js，点击开始=》运行=》输入"cmd" => 输入命令"path"，输出如下结果：。。。
      如果我们可以看到环境变量中已经包含了C:\Program Files\nodejs\就说明安装配置成功
  1.3、打开命令行输入指令node运行会发现命令行左上角会有-node字符，说明现在进入到了node运行环境输入console.log("第一条命令")，这只是用node运行简单
    的命令。如果想同时运行多行命令？--可以直接运行一个js文件，因为js文件里面是不限制命令多少的。具体方法，找到js所在的文件目录，运行node hello如下
    D:\environment\web APP\node_huigulianxi\first>node hello（hello.js中只有一条命令console.log("第一个node命令")
    第一个node命令
  1.4、npm使用
    允许用户从NPM服务器下载别人编写的第三方包到本地使用。
    允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。
    允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。
    npm 的包安装分为本地安装（local）、全局安装（global）两种，从敲的命令行来看，差别只是有没有-g而已，比如
    npm install express          # 本地安装
    npm install express -g   # 全局安装
    
    本地安装
    1. 将安装包放在 ./node_modules 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成
    node_modules 目录。
    2. 可以通过 require() 来引入本地安装的包。
    全局安装
    1. 将安装包放在 /usr/local 下或者你 node 的安装目录。
    2. 可以直接在命令行里使用。
  1.4、编写稍大一点的程序的时候一般都会讲代码模块化，在NodeJS中，一般将代码合理拆分到不同的JS文件中，每一个文件就是一个模块，而文件路径就是模块名。
  1.5、在编写每个模块时，都有require、exports、module三个预先定义好的变量可供使用。
  
      require:
          require函数用于在当前模块中加载和使用别的模块，传入一个模块名，返回一个模块导出对象。模块名可使用相对路径（以./开头），
          或者是绝对路径（以/或C:之类的盘符开头）。另外，模块名中的.js扩展名可以省略。以下是一个例子。

          var foo1 = require('./foo');
          var foo2 = require('./foo.js');
          var foo3 = require('/home/user/foo');
          var foo4 = require('/home/user/foo.js');
          // foo1至foo4中保存的是同一个模块的导出对象。
          另外，可以使用以下方式加载和使用一个JSON文件。
          var data = require('./data.json');
          
      exports:
          exports对象是当前模块的导出对象，用于导出模块公有方法和属性。别的模块通过require函数使用当前模块时得到的就是当前模块的exports对象。
          以下例子中导出了一个公有方法。

          exports.hello = function () {
              console.log('Hello World!');
          };  
      module:
          通过module对象可以访问到当前模块的一些相关信息，但最多的用途是替换当前模块的导出对象。例如模块导出对象默认是一个普通对象，
          如果想改成一个函数的话，可以使用以下方式。

          module.exports = function () {
              console.log('Hello World!');
          };
          以上代码中，模块默认导出对象被替换为一个函数。    
          ------------------------------------------------------------------------------------------------------------------------
          注意：一个模块中的JS代码仅在模块第一次被使用时执行一次，并在执行过程中初始化模块的导出对象。之后，缓存起来的导出对象被重复利用。
          var counter1 = require('./util/counter');
          var    counter2 = require('./util/counter');

          console.log(counter1.count());
          console.log(counter2.count());
          console.log(counter2.count());
          运行该程序的结果如下：

          $ node main.js
          1
          2
          3
          可以看到，counter.js并没有因为被require了两次而初始化两次。
          --------------------------------------------------------------------------------------------------------------------------

二、express安装
  2.1、
三、node服务器搭建
  3.1、事件驱动的异步服务器端JavaScript和它的回调。
    当我们使用 http.createServer 方法的时候，我们当然不只是想要一个侦听某个端口的服务器，我们还想要它在服务器收到一个HTTP请求的时候做点什么。
    问题是，这是异步的：请求任何时候都可能到达，但是我们的服务器却跑在一个单进程中。
    那么在我们的Node.js程序中，当一个新的请求到达8888端口的时候，我们怎么控制流程呢？嗯，这就是Node.js/JavaScript的事件驱动设计能够真正帮上
    忙的地方了
    我们创建了服务器，并且向创建它的方法传递了一个函数。无论何时我们的服务器收到一个请求，这个函数就会被调用。
    我们不知道这件事情什么时候会发生，但是我们现在有了一个处理请求的地方：它就是我们传递过去的那个函数。至于它是被预先定义的函数还是匿名函数，
    就无关紧要了。这个就是传说中的 回调 。我们给某个方法传递了一个函数，这个方法在有相应事件发生时调用这个函数来进行 回调 。
    
    var http = require("http");

    function onRequest(request, response){
      console.log("Request received.");
      response.writeHead(200,{"Content-Type":"text/plain"});
      response.write("Hello World");
      response.end();
    }
    http.createServer(onRequest).listen(8888);
    console.log("Server has started.");
    注意：在 onRequest （我们的回调函数）触发的地方，我用 console.log 输出了一段文本。在HTTP服务器开始工作之后，也输出一段文本。
    当我们与往常一样，运行它node server.js时，它会马上在命令行上输出“Server has started.”。当我们向服务器发出请求
    （在浏览器访问http://localhost:8888/ ），“Request received.”这条消息就会在命令行中出现。
    这就是事件驱动的异步服务器端JavaScript和它的回调啦！
    （请注意，当我们在服务器访问网页时，我们的服务器可能会输出两次“Request received.”。那是因为大部分服务器都会在你访问 http://localhost:8888 /
    时尝试读取 http://localhost:8888/favicon.ico )
  3.2、服务器是如何处理请求的
    我们的 onRequest() 函数被触发的时候，有两个参数被传入： request 和 response 。
    它们是对象，你可以使用它们的方法来处理HTTP请求的细节，并且响应请求（比如向发出请求的浏览器发回一些东西）。
    最后，我们调用 response.end() 完成响应。
  3.3、模块化处理
    目前，我们的HTTP服务器需要导出的功能非常简单，因为请求服务器模块的脚本仅仅是需要启动服务器而已。
    我们把我们的服务器脚本放到一个叫做 start 的函数里，然后我们会导出这个函数。
    var http = require("http");
    function start(){
      function onRequest(request, response){
        console.log("Request received.");
        response.writeHead(200,{"Content-Type":"text/plain"});
        response.write("Hello World");
        response.end();
      }
      http.createServer(onRequest).listen(8888);
      console.log("Server has started.");
    }
    exports.start = start;
    创建 index.js 文件并写入以下内容：
    var server = require("./server");
    server.start();
    正如你所看到的，我们可以像使用任何其他的内置模块一样使用server模块：请求这个文件并把它指向一个变量，其中已导出的函数就可以被我们使用了。
    这样，我们现在就可以创建我们的主文件 index.js 并在其中启动我们的HTTP了，虽然服务器的代码还在 server.js 中。
  3.4、请求路由处理
    处理不同的HTTP请求在我们的代码中是一个不同的部分，叫做“路由选择”——那么，我们接下来就创造一个叫做 路由 的模块吧。
    我们需要的所有数据都会包含在request对象中，该对象作为onRequest()回调函数的第一个参数传递。但是为了解析这些数据，我们需要额外的Node.JS模块，
    它们分别是url和querystring模块。
    解析url中所需要的信息，保存在变量pathname中，便于作为参数进行传递。
    定义router.js模块：
        function route(pathname){
          console.log("About to route a request for "+ pathname);
        }

        exports.route = route;
     然后把route函数作为参数传入到start函数中进行调用
     我们的服务器应当知道路由的存在并加以有效利用。我们当然可以通过硬编码的方式将这一依赖项绑定到服务器上，但是其它语言的编程经验告诉我们这会是
     一件非常痛苦的事，因此我们将使用依赖注入的方式较松散地添加路由模块（你可以读读Martin Fowlers关于依赖注入的大作来作为背景知识）。

    首先，我们来扩展一下服务器的start()函数，以便将路由函数作为参数传递过去：
     
    var http = require("http");
    var url = require("url");

    function start(route){
      function onRequest(request, response){
        var pathname = url.parse(request.url).pathname;
        console.log("Request for "+ pathname +" received.");

        route(pathname);

        response.writeHead(200,{"Content-Type":"text/plain"});
        response.write("Hello World");
        response.end();
      }

      http.createServer(onRequest).listen(8888);
      console.log("Server has started.");
    }

    exports.start = start;
    同时，我们会相应扩展index.js，使得路由函数可以被注入到服务器中：
    var server = require("./server");
    var router = require("./router"); 
    server.start(router.route);
    行为驱动执行
    请允许我再次脱离主题，在这里谈一谈函数式编程。

    将函数作为参数传递并不仅仅出于技术上的考量。对软件设计来说，这其实是个哲学问题。想想这样的场景：在index文件中，我们可以将router对象传递进去，
    服务器随后可以调用这个对象的route函数。
    路由，顾名思义，是指我们要针对不同的URL有不同的处理方式。例如处理/start的“业务逻辑”就应该和处理/upload的不同。
    我们暂时把作为路由目标的函数称为请求处理程序。现在我们不要急着来开发路由模块，因为如果请求处理程序没有就绪的话，再怎么完善路由模块也没有多大意义。

    应用程序需要新的部件，因此加入新的模块 -- 已经无需为此感到新奇了。我们来创建一个叫做requestHandlers的模块，并对于每一个请求处理程序，
    添加一个占位用函数，随后将这些函数作为模块的方法导出：
    function start(){
      console.log("Request handler 'start' was called.");
    }

    function upload(){
      console.log("Request handler 'upload' was called.");
    }

    exports.start = start;
    exports.upload = upload;
    最后再回到代码上来。现在我们已经确定将一系列请求处理程序通过一个对象来传递，并且需要使用松耦合的方式将这个对象注入到route()函数中。
    我们先将这个对象引入到主文件index.js中：

      var server = require("./server");
      var router = require("./router");
      var requestHandlers = require("./requestHandlers");

      var handle ={}
      handle["/"]= requestHandlers.start;
      handle["/start"]= requestHandlers.start;
      handle["/upload"]= requestHandlers.upload;

      server.start(router.route, handle);
      正如所见，将不同的URL映射到相同的请求处理程序上是很容易的：只要在对象中添加一个键为"/"的属性，对应requestHandlers.start即可，
      这样我们就可以干净简洁地配置/start和/的请求都交由start这一处理程序处理。

      在完成了对象的定义后，我们把它作为额外的参数传递给服务器，为此将server.js修改如下：
      var http = require("http");
      var url = require("url");

      function start(route, handle){
        function onRequest(request, response){
          var pathname = url.parse(request.url).pathname;
          console.log("Request for "+ pathname +" received.");

          route(handle, pathname);

          response.writeHead(200,{"Content-Type":"text/plain"});
          response.write("Hello World");
          response.end();
        }

        http.createServer(onRequest).listen(8888);
        console.log("Server has started.");
      }

      exports.start = start;
      这样我们就在start()函数里添加了handle参数，并且把handle对象作为第一个参数传递给了route()回调函数。

      然后我们相应地在route.js文件中修改route()函数：

      function route(handle, pathname){
        console.log("About to route a request for "+ pathname);
        if(typeof handle[pathname]==='function'){
          handle[pathname]();
        }else{
          console.log("No request handler found for "+ pathname);
        }
      }

      exports.route = route;
      通过以上代码，我们首先检查给定的路径对应的请求处理程序是否存在，如果存在的话直接调用相应的函数。
      我们可以用从关联数组中获取元素一样的方式从传递的对象中获取请求处理函数，因此就有了简洁流畅的形如handle[pathname]();的表达式，
      这个感觉就像在前方中提到的那样：“嗨，请帮我处理了这个路径”。
      
   3.5、让请求处理程序作出响应
        好，那么问题在哪里呢？简单的说就是： 当未来有请求处理程序需要进行非阻塞的操作的时候，我们的应用就“挂”了。
     3.5.1、以非阻塞操作进行请求响应
            用Node.js就有这样一种实现方案： 函数传递。
            现在我们采用如下这种新的实现方式：相对采用将内容传递给服务器的方式，我们这次采用将服务器“传递”给内容的方式。
            从实践角度来说，就是将response对象（从服务器的回调函数onRequest()获取）通过请求路由传递给请求处理程序。 随后，
            处理程序就可以采用该对象上的函数来对请求作出响应。
            
            简单来说就是通过上边的原理，吧response对象作为参数传递给router函数，
            先从server.js开始：

            var http = require("http");
            var url = require("url");

            function start(route, handle){
              function onRequest(request, response){
                var pathname = url.parse(request.url).pathname;
                console.log("Request for "+ pathname +" received.");

                route(handle, pathname, response);
              }

              http.createServer(onRequest).listen(8888);
              console.log("Server has started.");
            }

            exports.start = start;
            相对此前从route()函数获取返回值的做法，这次我们将response对象作为第三个参数传递给route()函数，并且，
            我们将onRequest()处理程序中所有有关response的函数调都移除，因为我们希望这部分工作让route()函数来完成。
            下面就来看看我们的router.js:

              function route(handle, pathname, response){
                console.log("About to route a request for "+ pathname);
                if(typeof handle[pathname]==='function'){
                  handle[pathname](response);
                }else{
                  console.log("No request handler found for "+ pathname);
                  response.writeHead(404,{"Content-Type":"text/plain"});
                  response.write("404 Not found");
                  response.end();
                }
              }

              exports.route = route;
              同样的模式：相对此前从请求处理程序中获取返回值，这次取而代之的是直接传递response对象。

              如果没有对应的请求处理器处理，我们就直接返回“404”错误。
              最后，我们将requestHandler.js修改为如下形式：

              var exec = require("child_process").exec;

              function start(response){
                console.log("Request handler 'start' was called.");

                exec("ls -lah",function(error, stdout, stderr){
                  response.writeHead(200,{"Content-Type":"text/plain"});
                  response.write(stdout);
                  response.end();
                });
              }

              function upload(response){
                console.log("Request handler 'upload' was called.");
                response.writeHead(200,{"Content-Type":"text/plain"});
                response.write("Hello Upload");
                response.end();
              }

              exports.start = start;
              exports.upload = upload;
              我们的处理程序函数需要接收response参数，为了对请求作出直接的响应。

              start处理程序在exec()的匿名回调函数中做请求响应的操作，而upload处理程序仍然是简单的回复“Hello World”，只是这次是使用
              response对象而已。
              到目前为止，我们做的已经很好了，但是，我们的应用没有实际用途。

              服务器，请求路由以及请求处理程序都已经完成了，下面让我们按照此前的用例给网站添加交互：用户选择一个文件，上传该文件，
              然后在浏览器中看到上传的文件。 
              为了保持简单，我们假设用户只会上传图片，然后我们应用将该图片显示到浏览器中。
   3.6、更有用的场景
   服务器，请求路由以及请求处理程序都已经完成了，下面让我们按照此前的用例给网站添加交互：用户选择一个文件，上传该文件，然后在浏览器中看到上传的文件。 
   为了保持简单，我们假设用户只会上传图片，然后我们应用将该图片显示到浏览器中。
   要实现该功能，分为如下两步： 首先，让我们来看看如何处理POST请求（非文件上传），之后，我们使用Node.js的一个用于文件上传的外部模块。
   之所以采用这种实现方式有两个理由。

      第一，尽管在Node.js中处理基础的POST请求相对比较简单，但在这过程中还是能学到很多。 
      第二，用Node.js来处理文件上传（multipart POST请求）是比较复杂的，它不在本书的范畴，但，如何使用外部模块却是在本书涉猎内容之内。
      我们来探讨一个更有趣的问题： 当用户提交表单时，触发/upload请求处理程序处理POST请求的问题。

      现在，我们已经是新手中的专家了，很自然会想到采用异步回调来实现非阻塞地处理POST请求的数据。

      这里采用非阻塞方式处理是明智的，因为POST请求一般都比较“重” —— 用户可能会输入大量的内容。用阻塞的方式处理大数据量的请求必然会导致用户操作的
      阻塞。
      为了使整个过程非阻塞，Node.js会将POST数据拆分成很多小的数据块，然后通过触发特定的事件，将这些小数据块传递给回调函数。这里的特定的事件
      有data事件（表示新的小数据块到达了）以及end事件（表示所有的数据都已经接收完毕）。

      我们需要告诉Node.js当这些事件触发的时候，回调哪些函数。怎么告诉呢？ 我们通过在request对象上注册监听器（listener） 来实现。
      这里的request对象是每次接收到HTTP请求时候，都会把该对象传递给onRequest回调函数。
      我们需要告诉Node.js当这些事件触发的时候，回调哪些函数。怎么告诉呢？ 我们通过在request对象上注册监听器（listener） 来实现。这里的request对象
      是每次接收到HTTP请求时候，都会把该对象传递给onRequest回调函数。
      在我看来，获取所有来自请求的数据，然后将这些数据给应用层处理，应该是HTTP服务器要做的事情。因此，我建议，我们直接在服务器中处理POST数据，
      然后将最终的数据传递给请求路由和请求处理器，让他们来进行进一步的处理。

      因此，实现思路就是： 将data和end事件的回调函数直接放在服务器中，在data事件回调中收集所有的POST数据，当接收到所有数据，触发end事件后，
      其回调函数调用请求路由，并将数据传递给它，然后，请求路由再将该数据传递给请求处理程序。

      还等什么，马上来实现。先从server.js开始：
      var http = require("http");
      var url = require("url");

      function start(route, handle){
        function onRequest(request, response){
          var postData ="";
          var pathname = url.parse(request.url).pathname;
          console.log("Request for "+ pathname +" received.");

          request.setEncoding("utf8");

          request.addListener("data",function(postDataChunk){
            postData += postDataChunk;
            console.log("Received POST data chunk '"+
            postDataChunk +"'.");
          });

          request.addListener("end",function(){
            route(handle, pathname, response, postData);
          });

        }

        http.createServer(onRequest).listen(8888);
        console.log("Server has started.");
      }

      exports.start = start;
      上述代码做了三件事情： 首先，我们设置了接收数据的编码格式为UTF-8，然后注册了“data”事件的监听器，用于收集每次接收到的新数据块，
      并将其赋值给postData 变量，最后，我们将请求路由的调用移到end事件处理程序中，以确保它只会当所有数据接收完毕后才触发，并且只触发一次。
      我们同时还把POST数据传递给请求路由，因为这些数据，请求处理程序会用到。

      上述代码在每个数据块到达的时候输出了日志，这对于最终生产环境来说，是很不好的（数据量可能会很大，还记得吧？），但是，在开发阶段是很有用的，
      有助于让我们看到发生了什么。

      我建议可以尝试下，尝试着去输入一小段文本，以及大段内容，当大段内容的时候，就会发现data事件会触发多次。
      再来点酷的。我们接下来在/upload页面，展示用户输入的内容。要实现该功能，我们需要将postData传递给请求处理程序，修改router.js为如下形式：

      function route(handle, pathname, response, postData){
        console.log("About to route a request for "+ pathname);
        if(typeof handle[pathname]==='function'){
          handle[pathname](response, postData);
        }else{
          console.log("No request handler found for "+ pathname);
          response.writeHead(404,{"Content-Type":"text/plain"});
          response.write("404 Not found");
          response.end();
        }
      }

      exports.route = route;
      然后，在requestHandlers.js中，我们将数据包含在对upload请求的响应中：
      function upload(response, postData){
          console.log("Request handler 'upload' was called.");
          response.writeHead(200,{"Content-Type":"text/plain"});
          response.write("You've sent: "+ postData);
          response.end();
        }
     好了，我们现在可以接收POST数据并在请求处理程序中处理该数据了。

      我们最后要做的是： 当前我们是把请求的整个消息体传递给了请求路由和请求处理程序。我们应该只把POST数据中，我们感兴趣的部分传递给请求路由
      和请求处理程序。在我们这个例子中，我们感兴趣的其实只是text字段。

      我们可以使用此前介绍过的querystring模块来实现：

      var querystring = require("querystring");
      function upload(response, postData){
          console.log("Request handler 'upload' was called.");
          response.writeHead(200,{"Content-Type":"text/plain"});
          response.write("You've sent the text: "+
          querystring.parse(postData).text);
          response.end();
        }
    
四、restful风格服务器搭建
