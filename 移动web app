1、做demo时可以用div代替图片
2、px = （dpr）*（dpr）*dp   dpr：设备像素缩放比   dp：设备物理像素   px：css pixels 逻辑像素，浏览器使用的抽象单位
当dpr=2的时候 1px=4*dp 即一个css像素等于4个物理像素渲染  换个角度 也就是1px的长度就等于2dp（2个物理像素的长度） 1px高度等于2个物理像素的高度
当设备为640dp*1136dp时 dpr=2的情况下对应的应该是320px*568px

------------------------------------------------------------------------------------------------------------------------------------
如iPhone5 主屏分辨率：1136*640像素
而屏幕尺寸是320px

实际照片像素是640像素，显示在了320px的屏幕上。dpr为2 1px宽度上实际存在两个像素 所以我们在css里面设置px为单位时，此时的1px为两dp
当设备宽度为320时，我们用css设置360会超出屏幕一部分。

------------------------------------------------------------------------------------------------------------------------------------

3、viewport
------------------------------------------------------------------------------------------------------------------------------------
viewport翻译过来是：可视区窗口。是用来设置可视区大小缩放等功能
默认是980px，也就是当我们不设置meta标签时自然显示的效果，100px占整个页面的十分之一。
为了用户体验方便，可视区大小是可以设置的通过content="width=device-width"，此时的意思是，将页面渲染到一个和设备宽度一样的viewport里
结果就是页面在和设备宽度一样的窗口进行了显示。再透彻的理解就是只要在这个页面进行修改就行不用管原页面是多大，什么情况。因为手机浏览器已经做了处理的

总结：设置为content="width=device-width"之后我们所需要编辑的页面就和原来页面大小完全没关系了。
------------------------------------------------------------------------------------------------------------------------------------
ios的viewport 默认是980px
viewport做了两件事情：1、页面被渲染在了一个默认为980px（ios）的viewport里面 2、通过缩放使你看到整个viewport全貌（viewport即手机浏览器默认做的
两个事情）
viewport由两个部分构成：视图viewport（visual viewport）和布局viewport（layout viewport  这的viewport是指980px那个而不是原页面大小）
4、移动web最佳viewport设置：
  视图viewport=设备宽度=布局viewport
  <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
  
5、flexbox布局：
Android4.4以下只兼容旧版本的flex ，ios兼容最新的flex

6、响应式设计：
媒体查询 百分比布局 弹性图片

7、多行文本溢出：
.intwoline{
  display:-webkit-box!important;
  ovwerflow:hidden;
  text-ovwerflow:ellipsis;
  work-break:break-all;
  -webkit-box-orient:vertical;
  -wwbkit-line-clamp:2;
  }





webAPP缺点：
1、只能使用有限的移动硬件和设备功能（）
2、在低端机Android4.4以下会明显的卡顿
3、在复杂交互，动画时会出现白屏卡顿现象
原生APP缺点：
1、分平台开发
2、后期维护麻烦

混合APP缺点：


APP可以分为两类：
1、以内容为主的文档类
  主要靠纯HTML5来实现
2、以行为交互为主的应用类
  如果APP功能不强，知名度不高即使做成了原生APP也不会有人安装
  做类似于微信的社交软件，小说阅读软件用混合APP比较好
  
混合APP种类：
view可以理解为手机界面，一个界面就是一个view
1、多view混合类型
原生界面和网页开发的界面独立展示，交替出现。对交互要求比较高的用原生界面来实现，要求不高的用网页页面来实现
2、单view混合类型
同一个界面里面。原生界面和web界面为层叠关系，同时出现
3、web主体型
应用主体是一个网页，穿插了原生功能
用户体验的好坏主要取决于底层中间件的交互和跨平台能力

原理：用前端技术开发好应用界面，借助一个APP打包框架和运行环境。根据不同的运行平台生成不同的手机运行安装包。
APP打包框架相当于一个工厂。

混合APP框架：
国外比较有名的：phonegap后来被收购改名为codvar
国内：此处采用dcloud公司的hbuild

手机模拟器：























默认样式修改：
1、去掉默认的电话和邮箱识别 ：
  用：<a href="tel:18888888888">请拨打18888888888</a>    <a href="mailto:15188961373@163.com">请发送邮件</a>    来代替
2、去掉a、input、button点击时的阴影  ：a{ -webkit-tap-highlight-color:rgba(0,0,0,0)} 将点击时的背景色设为全透明
3、消除按钮圆角：button{ -webkit-appearance:none; border-radious:0}
4、默认字体设置：body{font-family:Helvetica}  因为每台设备的默认字体不一样，而这个是所有设备都有的一个字体，不过只是英文字体
5、禁止用户修改字体大小：-webkit-text-size-adjust:100%;
6、可以取消移动端的长按默认选中的效果。不过兼容不太好
7、font Boosting：webkit内核下，当一段文字我们没有设置高度的时候，文字的大小可能被浏览器放大。解决办法：设置最大高度max-hight
8、固定定位问题fixed（需要用事件去处理）
9、ios body 的overflow问题：当页面宽度超出屏幕宽度之后，给body设置overflow：hidden position：relative 然后用div将内容主题包起来设置
  overflow：auto；此时横向就拖不动了

适配：
1、百分比适配：宽度可以设置百分比，高度设置一般为固定值，因为高度适配比较复杂，所以百分比适配一般用来配合其他适配方式，起辅助作用
2、viewport适配：用js获取设备尺寸，然后通过缩放将viewport强制限定为320px，动态添加meta标签到dom元素来实现document.head.appendchild(meta)
3、rem适配：
4、弹性盒模型（box版和flex版）

移动端body有默认8xp的margin，要进行初始化
box-sizing 属性允许你以某种方式定义某些元素，以适应指定区域。假如您需要并排放置两个带边框的框，可通过将 box-sizing 设置为 "border-box"。
这可令浏览器呈现出带有指定宽度和高度的框，并把边框和内边距放入框中。

rem适配布局 写页面步骤：
1、设置meta标签，利用js设置html字体大小
  <script>
        (function () {
            var html = document.documentElement;
            var hwidth = html.getBoundingClientRect().width;
            console.log(hwidth);
            html.style.fontSize=hwidth/16 + "px";
        })()
    </script>
    当页面宽度为320px时，1rem=20px
    
    但是当我们的设计图是750px时，就应该用750去除以16 此时设计图的1rem=750/16 同理 如果设计图中元素宽度为100px则他对应的rem为100/(750/16)
    而不是按设备宽度的1rem=20px去换算。原理是：
    将750px的图在320px的设备上进行展示，按比例换算：1rem对应的都是将宽度划分为16份，按百分比计算就对了。
    简单记：设计图里面单位换算：1rem=设计图宽度除以16
            
    
2、清除移动端默认样式
3、编写页面
  在移动端为了用户点击按钮方便一般把按钮至于中间位置，方便点击和布局
4、可以用考拉工具来编译sass
5、引入bootstrap，此处需要注意的是如果我们只需要他的font字体，那么可以只使用bootstrap.css里面的部分代码和font文件，其他都不需要
6、图表字体一定要设置字体大小
7、小的位置微调时，上下左右用top left去控制
8、a标签里面不要再嵌套div 用span来代替

弹性盒子布局
1、使用sass时文件路径中不能有汉字
  使用sass时，value和key之间要加个空格，编译才会正常如：-webkit-box-pack: end
2、使用老版flex进行移动端布局，老版兼容更好
  
  display:-webkit-box(等同于flex)
  主轴方向：flex-direction: row(主轴方为水平方向) flex-direction: column（主轴方向为垂直方向） 老版-webkit-box-orient: horizontal
  主轴方向富余空间的管理：老版-webkit-box-pack: end/start/center/justify相比较于新版缺少部分功能
  侧周方向富余空间的管理：老版-webkit-box-align: center/start/end想比较于新版缺少部分功能
  弹性空间：是在子集设置针对该元素本身的（上边的都是在父级设置的）。老版-webkit-box-flex: 1
  设置元素的具体位置：老版-webkit-box-ordinal-group: 3 接受一个数值，值越小该元素越靠前，最小默认处理为1（0和负值会被当做1来处理）。新版能正常接受
    并识别0和负数
    
移动端精灵图制作
1、写viewport的meta标签
2、初始化html根元素的字体大小（主要针对于设计图来进行计算。如750px设计图分成15份，则在设计图中量到的50px都可以用1rem来表示）
3、清除默认样式
4、因为老版flex-box不会自动换行，所以一行占不下的情况就按2块或多块处理
5、在flex布局中，盒子内部元素的大小会影响到盒子的大小。给该盒子设置width：0px，就不会受到盒子尺寸的影响了  div{width: 0;-webkit-box-flex: 1;
    flex-grow: 1}此时的flex为1就会平分。
6、在移动端必须要设置一下背景图片和图片的大小
    a:before
          content: ''
          display: block
          margin: 0 auto
          width: 86rem/$r
          height: 85rem/$r
          background-image: url("../img/01.jpg")
          background-size: 86rem/$r 85rem/$r

.rows:nth-of-type(2)
  div:nth-of-type(1) a:before
    background-image: url("../img/06.jpeg")
  div:nth-of-type(2) a:before
    background-image: url("../img/07.jpg")
  div:nth-of-type(3) a:before
    background-image: url("../img/08.jpg")
  div:nth-of-type(4) a:before
    background-image: url("../img/09.jpg")
  div:nth-of-type(5) a:before
    background-image: url("../img/10.png")


当制作雪碧图时，图片与图片之间要预留一点缝隙，比如86*85的图片制作雪碧图时要占位90*90的大小，这样可以避免图片缩放时因为小数点引起的问题。第一个位置
图片以左上角为起点，这样调整位置的时候就是以0,0开始background-position: 0 0

响应式：
媒体查询检查屏幕横竖屏
1、利用媒体查询引入不同的css样式表：<link rel="stylesheet" href="./css/01.css" media="all and (min-width:400px)"/>
     @import url(./css/01.css) (max-width: 767px);
     
     
     
 移动端事件：
 1、移动端的三大事件：手指按下ontouchstart 手指移动ontouchmove 手指抬起ontouchend
 2、注意：在移动端开发的时候，浏览器的模拟器时好时坏，一般不用on的形式绑定事件函数要用事件绑定的形式（addEventListener）：
    var div=document.getElementById('div1');
    div.addEventListener("touchstart",start);
    function start() {
        alert(1)
    }
3、pc上的事件比移动端的事件略慢，大概300ms
4、点透：当上层元素发生点击的时候，下层元素也有点击（焦点）特性。在300ms之后如果上层元素消失（隐藏）。目标点就会“漂移”到下层元素身上，就会触发下层
    元素的点击行为
    解决方案：阻止pc事件
        document.addEventListener("touchstart",function (ev) {
            ev.preventDefault();
        })（触发touchart事件后，立即触发阻止pc事件的函数，后边执行的函数就不会再触发pc事件）
        这样在使用touchstart的时候就不会触发该元素下面一层的a标签，当然当该元素消失之后点击a标签不会进行跳转，因为pc默认的a链接事件已经被阻止。
        若要a标签能正常跳转需要添加touchstart事件给a标签：
        a.addEventListener("touchstart",function () {
          window.location.href="http://www.baidu.com";
        })
  阻止pc事件之后还有一些其他好处：
  （1）、禁止pc事件之后可以解决ios10下用meta标签设置禁止用户缩放无效的bug
  （2）、禁止pc事件后可以解决ios10下溢出隐藏的问题：
        body, html {
            width: 100%;
            overflow: hidden; }
   （3）、可以禁止系统默认的滚动条，阻止橡皮筋效果
   （4）、可以禁止系统长按选中文字和图片，禁止长按弹出的菜单
   （5）、解决点透问题
   （6）、阻止了焦点元素（input等）的焦点行为。如果想点击input框获得焦点通过
         txt.addEventListener("touchstart",function (ev) {
              ev.stopPropagation()//阻止事件冒泡
          })
          来达到效果
          
移动端的事件对象：当某个元素加上了事件绑定函数之后，事件函数默认的第一个参数，就是事件对象。作用：当用户在浏览器下触发了某个行为，事件对象会记录用户操作时
              一些细节信息。比如点击屏幕某个位置时获取手指的坐标
              function start(ev) {
                  this.innerHTML=ev.touches.length
              };
            此处的ev就是事件对象
     1、touchevent：
     （1）、touches：当前位于屏幕上所有手指的一个列表
        
     
     （2）、targetTouches:位于当前dom元素上的手指的一个列表
     （3）、changedTouches：涉及当前事件的手指的一个列表
          一般会用这个事件对象


用事件编写移动端轮播图：
1、设置meta标签
2、设置根节点字体大小
3、阻止pc和浏览器默认行为
4、

移动端transfrom：
1、设置meta标签
2、清除默认样式
3、清除默认事件


transfrom2d：
（1）、写法：-webkit-transfrom 加前缀兼容性更好
在函数中添加动画的写法：div.style.WebkitTransfrom = div.style.transform = 'rotate(90deg)' 为了方便在pc端进行调试这样写兼容更好
(2)、设置变换的原点：
在css中设置.box{
     transition: 1s;
    -webkit-transform-origin: 0 0;
    transform-origin: 0 0;（接受百分比，距离单位（px，rem），关键字（center,left,top））
}
（3）、执行顺序
div.style.transform = 'translate(100px) rotate(180deg)' 先旋转 后平移（先写的后执行）
（4）、动画
修改left值的性能是比较差的，修改left和top会引起元素回流，因此在移动端不推荐使用修改left和top的值去进行动画，更推荐使用translate去修改元素的位置
去做动画，性能会好很多。
transfrom中的大坑：矩阵
获取元素计算后的样式：console.log(getComputedStyle(div[0])["transfrom"]) 获取第一个div的transfrom计算后的属性，得到的结果是一个矩阵
在做IE兼容的时候可能需要用到矩阵，到时候再去了解

（5）、transfrom3D
-webkit-perspective: 200px
    perspective: 200px// 景深 （近大远小）加给要做3d变换元素的父级
    景深还有一个原点设置： -webkit-perspective-origin: x y
                          perspective-origin: x y 默认值是center center 效果可以简单理解为视线，即从哪个方向看元素
    3d动画主要有：
    一、rotateX(60deg)旋转
    二、translate位移
    三、-webkit-transform-style: flat
        transform-style：flat（preserve-3d）元素在做3d变换时是否保留子元素的3d效果，默认是flat即不保留
        
    隐藏背面：反面（背面）：和父级角度相对的元素即为背面    
    可以使用backface-visibility: hidden
    -webkit-backface-visibility: hidden来隐藏背面，效果就是正面如果小于背面，则看不到背面的背景
    
transfrom动画：
1、获取动画的状态和属性：
  （1）、transfrom的相关设置：
    自定义一个函数cssTransfrom()里面包含3个参数，元素、属性、和值。如果要获取transfrom相关属性，那transfrom的相关设置必须要通过该函数进行设置，
    如果直接在css中定义，那么将获取不到相关属性
    function cssTransfrom(element,attr,val) {
            if(typeof val == "undefined"){
                console.log('获取');
            }else {
                console.log('设置');
            }
        }
    因为一个元素的transfrom可能会有多个，所以定义一个对象，用来存储某个元素的transfrom属性
    element.transform={
                rotate:40,
                scale:200,
                skew:'',
                translate:20
            };
            console.log(element.transform.rotate)
    （1）、为了避免小数误差，可以将设置的小数*100来进行赋值
    
    （2）、编写cssTransfrom()函数时首先要判断是否含有element.transform属性，如果不存在说明该以前没有进行transfrom属性设置，此时需要给他
    创建一个对象形式的属性：element.transform = {};用来存储相关的属性操作。   如果存在，说明以前已经进行过transfrom设置
    （3）、当属性值不存在时，只需要 return element.transform[attr] 就可以得到我们想要获取的属性值。不过如果之前没有用CSSTransfrom（）进行
    设置过参数，那么直接获取属性就会为undefined，所以我们要给他添加默认值，即即使没有设置属性也应该存在一个默认的值能够获取到。
    （4）、用switch方法进行匹配：变量fruit的值，选择执行相应的case如果所有case都不符合，则执行最后的default部分。需要注意的是，每个case
          代码块内部的break语句不能少，否则会接下去执行下一个case代码块，而不是跳出switch结构。
    （5）、设置属性原理就是：将val值赋给element.transform[attr]   即element.transform[attr] = val  
      为了方便清晰的记录transfrom属性需要利用for循环将属性进行记录，避免被覆盖
      
      
cssTransfrom 函数整体代码如下：
         <script>
        document.addEventListener('touchstart',function (ev) {
            ev.preventDefault();
        });
        function cssTransfrom(element,attr,val) {
//            element.transform={
//                rotate:40,
//                scale:200,
//                skew:'',
//                translate:20
//            };
//            console.log(element.transform.rotate)
            if (!element.transform){
                element.transform = {};
            }
            if(typeof val == "undefined"){
                var val = element.transform[attr];
                if (!element.transform[attr]){
                //表示该元素没有通过这种方法创建过transfrom，那我们就返回默认值
                    switch (attr){
                        case "scale":
                        case "scaleX":
                        case "scaleY":
                        case "scaleZ":
                            element.transform[attr] = 100;
                            break;
                //当attr匹配到上边任一一个值的时候都会执行到element.transform[attr] = 100;然后break跳出循环
                        default:
                            element.transform[attr] = 0;
                //如果不是scale的其他情况都为0
                    }
                }
                return  element.transform[attr];
//                console.log('获取');
            }else {
                element.transform[attr] = val;
                var transformVal = '';
                for (var s in element.transform){
//                    console.log(s);
                    switch (s){
                        case "scale":
                        case "scaleX":
                        case "scaleY":
                        case "scaleZ":
                            transformVal += ' ' + s + '('+ (element.transform[s]/100)+')';//注意此处必须用element.transform[s]因为这样
                            //在循环的时候才能正确找到对应属性的key。比如rotate：30 translateX：100 这样才能正确赋值
                            break;
                        case "rotate":
                        case "rotateX":
                        case "rotateY":
                        case "rotateZ":
                        case "skewX":
                        case "skewY":
                            transformVal += ' ' + s + '('+ element.transform[s]+'deg)';
                            break;
                        default:
                            transformVal += ' ' + s + '('+ element.transform[s]+'px)';
                    }
                }
                console.log(transformVal) ;
                element.style.WebkitTransfrom = element.style.transform = transformVal
//                console.log('设置');
            }
        }
        window.onload = function () {
            var div = document.querySelector('#div');
//            console.log(getComputedStyle(div)["transfrom"])
            div.addEventListener('touchend',function () {
                var deg = cssTransfrom(div,'rotate');
                deg += 30;
                cssTransfrom(div, 'rotate',deg);
//                console.log(cssTransfrom(div, 'rotate',deg))
            });

        }
    </script>
    好处：直观，不容易因为单位而导致出错。
  该函数存在一个问题，就是设置不同transfrom时，他的上一个val值会被下一个覆盖：初步解决思路直接给参数赋单位，不用switch判断，这样就不用走循环。
  
  可以换为如下方案：
  else {
        element.transform[attr] = val;
        var transformVal = attr + '(' + val + ')';
        console.log(1);
        element.style.WebkitTransfrom = element.style.transform += transformVal;
        console.log(element.style.transform);
          }
----------------------------------------------------------------------------------------------------------------------

transfrom有的时候并不够用，因此有的时候使用MTween（运动）效果更好：

先写静态页面：
处理掉图片空隙：display：block

用mtween写有些费事，因为图片要一直在旋转，用它的话需要用定时器不停的跑，如果
在移动端想让他性能高一点，尽量还是用它原生就有的东西，用animation来写。

先添加一个关键帧
html,body
  height: 100%
  position: relative
#load
  height: 100%
  position: relative
  perspective: 300px
  -webkit-perspective: 300px
  #load1,#load2
    position: absolute
    top: 45%
    left: 20%
    width: 60%
    transform-style: preserve-3d
    -webkit-transform-style: preserve-3d
    img
      width: 100%
      display: block
      animation: 3s infinite linear rotate
      -webkit-animation: 3s infinite linear rotate

@keyframes rotate
  0%
    transform: rotateY(0deg)
  100%
    transform: rotateY(360deg)

@-webkit-keyframes rotate
  0%
    -webkit-transform: rotateY(0deg)
  100%
    -webkit-transform: rotateY(360deg)
    
 现在旋转已经写完了，然后是从前到后的过程：
 


