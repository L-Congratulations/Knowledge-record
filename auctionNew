一、创建项目
1.1、在命令行中：ng new auction --routing  运行ng serve 检查程序运行是否正常
1.2、引入外部库：首先在当前项目中引入库npm i jquery --save   npm i bootstrap --save
然后把库引入到项目中：在angular.cli.json文件中添加
"styles": [
        "styles.css",
        "../node_modules/bootstrap/dist/css/bootstrap.css"
      ],
      "scripts": [
        "../node_modules/jquery/dist/jquery.js",
        "../node_modules/bootstrap/dist/js/bootstrap.js"
      ],
1.3、安装库的类型描述文件（将JavaScript所写的东西转化为typescript能识别的文件），这样typescript才能认识这些库中的代码。
npm i @types/jquery --save-dev   npm i @types/bootstrap --save-dev

二、项目开发

2.1、项目架构分析（目的是为了开发可重用的组件，用组件化的思路思考）
项目需要分成多少个组件开发：根据功能进行划分为若干个小的组件（在本项目中可划分：app组件，就是最外层的跟组件、导航栏组件、footer组件、搜索表单组件、
轮播图组件、产品列表展示组件、星级评价组件）

2.2、根据划分的组件使用angular命令行生成对应的组件：
ng g component navbar  ng g component footer   ng g component search  ng g component carousel   ng g component product
ng g component stars

2.3、组件静态页面编写
因为组件可以通过标签直接引用，所以编写的时候就是根据UI图中组件所在的位置给他进行定位
然后就是写具体组件中的样式
private starts: Array<boolean>;
private products: Array<Product>;
  constructor() { }

  ngOnInit() {
    this.products = [
      new Product(1, '第一个商品', 1.88, 3.5, 'angular4.0', ['图书', '硬件设备'], '../../assets/imgs/3.png'),
      new Product(2, '第二个商品', 2.88, 2.5, 'angular4.0', ['电子产品', '硬件设备'], '../../assets/imgs/1.png'),
      new Product(3, '第三个商品', 3.88, 4.5, 'angular4.0', ['硬件设备'], '../../assets/imgs/2.png'),
      new Product(4, '第四个商品', 4.88, 2.5, 'angular4.0', ['电子产品'], '../../assets/imgs/1.png'),
      new Product(5, '第五个商品', 5.88, 1.5, 'angular4.0', ['图书'], '../../assets/imgs/2.png'),
      new Product(6, '第六个商品', 6.88, 4.5, 'angular4.0', ['图书', '硬件设备'], '../../assets/imgs/3.png')
    ];
  }
  <span *ngFor="let star of starts" class="glyphicon glyphicon-star" [class.glyphicon-star-empty]="star"></span>

三、路由应用

3.1、创建商品详情组件ng g component productDetail
因为要从路由中获取到参数，所以需要在constructor中注入
export class ProductDetailComponent implements OnInit {
  private productTitle: string;
  private productImg: string;
  constructor(private routeInfo: ActivatedRoute) { } // 注入ActivatedRoute

  ngOnInit() {
    this.productTitle = this.routeInfo.snapshot.params['productTitle']; // 将从路由中获取到的
    // 参数赋值给自己定义的变量。在这的配置是和路由中配置相匹配的
    this.productImg = '../../assets/imgs/2.png';
  }

}

3.2、定义一个home组件用来包含轮播和商品列表组件

3.3、将app.component.html中原来放置轮播和列表的地方用插座替换
<div class="col-md-9">
      <router-outlet></router-outlet>
    </div>
注意：路由切换的是插座内的内容

3.4、配置路由：根据路径的不同，切换插座内显示的内容
const routes: Routes = [
  {
    path: '', component: HomeComponent,
  },
  {path: 'product/:productTitle', component: ProductDetailComponent}
];

3.5、配合路由传递参数，在product.component.html中：
<h4 class="pull-left"><a [routerLink]="['/product', product.title]">{{product.title}}</a></h4>来配合路由将title传递出去

四、依赖注入

4.1、编写produServes,我们封装了一个服务将所有和商品信息和评论相关的东西进行了封装，可以在多个组件中进行复用
使用angular命令行在一个shared文件夹下创建一个服务，因为这个服务会在多个组件中共享，所以单独拿到shared文件夹：ng g service shared/product

数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，
然后返回该成员。如果没有符合条件的成员，则返回undefined。[1, 4, -5, 10].find((n) => n < 0)

函数的返回值也可以定义类型：
 getProducrs() {
    return this.products;
  }
  getProduct(id: number): Product { // 的返回值在这定义为了Product类型
    return this.products.find((product) => product.id === id);
  }
  getCommentForProductId(id: number): Comment[] { // 注意这因为是用的是fillter返回的是所有符合要求的数据应该是个数组
    return this.comments.filter((comment: Comment) => comment.productId === id);
  }
  4.2、将路由传商品名称改为传商品id，获取到商品id之后根据id调用服务中的数据
  4.3、注入服务并调用。
  首先在使用服务之前要注册在！！模块！！的providers上 providers: [ProductService],
  然后在需要使用服务的组件上注入：
  export class ProductComponent implements OnInit {
  private products: Array<Product>;
  constructor(private productService: ProductService) { } // 在构造函数中注入服务

  ngOnInit() {
    this.products = this.productService.getProducts(); // 注入服务之后就可以调用服务中的函数
  }

}
然后调用函数
注意，从路由中获取的参数是字符串，需要使用parseInt转化为整数，在使用parseInt转化为整数之后用===进行比较。在ts中parseInt的第二个参数不能省略。
0代表10进制
const productId = parseInt(this.routeInfo.snapshot.params['productId'], 0);
注意同一个class类可能会有很多个声明，要选择对应的声明

五、响应式编程


六、编写评论组件
6.1、首先要给星级组件添加点击事件，然后需要知道点击的是哪颗星星，所以需要传入一个脚标。
<span *ngFor="let star of start; let i = index" class="glyphicon glyphicon-star"
        [class.glyphicon-star-empty]="star" (click)="clickStar(i)"></span>
 clickStar也生成了5次，比如点击第五个星星时，触发的函数式clickStar(5).给五颗星星添加了五个clickStar(i)函数，根据i的不同触发不同的函数
 
 当点击星星的时候触发函数：
 clickStar(index: number) {
    this.rating = index + 1;
    this.ngOnInit(); // 调用类里面的函数也是通过this来调用
  }
  重置rating然后重新调用方法重置stars数组，从而刷新星星的组件。
  
  4.2、星级评价分为两个状态，只读和可修改。
 隐藏需要定义一个变量，根据变量的布尔值来判断是否是只读，通过在angular中使用属性绑定来修改变量的布尔值，从而修改星级评价的属性
 @Input()  private readonly = true; // 因为需要通过属性绑定修改组件是否可读
clickStar(index: number) {
    if (!this.readonly) {
      this.rating = index + 1;
      this.ngOnInit(); // 调用类里面的函数也是通过this来调用
    }
  }
  4.3、评论组件
  在新的评论中，我们做了两件事，一个是评级（几星），一个是评价
默认星级为5星，评价内容为空：
private newRating = 5;
  private newComment = '';
  
  然后在html中添加模板样式：
  <app-stars [rating]="newRating" [readonly]="false"></app-stars>
    <textarea [(ngModel)]="newComment"></textarea>   // 使用双向绑定前要引入FormsModule才能正常使用
    <button class="btn" (click)="addComment()">提交</button>
    
    添加addComment()函数。原理就是重新创建一个comment对象，然后将新对象添加到comments数组中
    addComment() {
    const comment = new Comment(0, this.product.id, new Date().toISOString(), 'someone', this.newRating, this.newComment);
    this.comments.unshift(comment);
  }
  双向绑定星级评分：
  @Input() rating: number;
   @Output() ratingChange: EventEmitter<number> = new EventEmitter();
   <app-stars [(rating)]="newRating" [readonly]="false"></app-stars>
   这时候评论组件中的rating变化也会影响到comments中rating的变化
   this.ratingChange.emit(this.rating);
4.4、按钮控制评论组件的显示和隐藏
首先定义一个变量，iscommenthidden=true，即默认是隐藏状态
<button class="btn btn-success" (click)="isCommentHidden = !isCommentHidden"></button>
    <div [hidden]="isCommentHidden">
    然后通过事件绑定和属性绑定进行切换
4.5、表单初始化：
this.newRating = 5;
    this.newComment = null;
    this.isCommentHidden = true;
    此时虽然通过双向绑定初始了rating的值，但是并没有初始starts数组，因此想要初始化数组需要使用OnChanges
    export class StarsComponent implements OnInit, OnChanges { // 注意这块要用逗号隔开 
    ngOnChanges(changes: SimpleChanges): void {
    this.stars = [];
    for (let i = 1; i < 6; i++) {
    this.stars.push(i > this.rating);
    }
  }
  此时触发：
  clickStar(index: number) {
    if (!this.readonly) {
      this.rating = index + 1;
      this.ratingChange.emit(this.rating);
    }
  }里面的输入属性rating，就会触发ngOnChanges，从而更新视图
4.7、计算所有评论的平均值：
思路：当点击提交按钮的时候获取到所有的评论值，然后进行计算
 const sum = this.comments.reduce((sums, comments) => sums + comments.rating, 0);
    this.product.rating = sum / this.comments.length;
    {{rating | number:'1.0-2'}}

五、http服务
5.1、用node搭建简单的服务器：
在项目同级目录下新建一个文件夹server 使用mpm init -y 初始化
然后引入node的类型描述文件（让typescript写的代码node可以认识）npm i @types/node --save
然后新建一个tsconfig.json来让typescript编译成JavaScript：
{
  "compilerOptions": {
    "module": "commonjs",
    "target": "es5",
    "sourceMap": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "outDir": "build",
    "lib": ["es6"]
  },
  "exclude": [
    "node_modules"
  ]
}
可能还需要配置下webstrom
5.2、安装express框架：
npm i express --save 然后装express类型定义文件： npm i @types/express --save
安装node热加载模块：npm i nodemon -g
在server文件夹下新建一个文件auction_server.ts文件来编写服务
启动服务：nodemon build/auction_server.js
然后就是把客户端编写的数据拿到服务器。
主要是类的定义和假数据
