一、以大漠穷秋的NiceFish为案例进行
1.1 将项目克隆下来并在本地运行（已经安装好了angular-cli）
1.克隆项目： git clone https://github.com/lzxb/vue-c...
2.安装nodejs
3.进入项目NiceFish目录 安装依赖： npm install（根据需求看是用cnpm还是npm安装）
4.启动服务： ng serve --prod --aot 
如果down下来的项目中angular-cli的版本和电脑中装的不一致需要把电脑中的cli卸载：npm uninstall -g angular-cli
然后重新安装 npm install -g @angular/cli
如果还是有问题就重新down一遍代码然后配置。因为有的时候可能存在文件依赖顺序。

2.3、cli常用技巧
2.3.1、cli默认不会创建路由，要想创建好的项目里面包含路由，需要在运行时输入：ng new demoname --routing
2.3.2、ng server 有个port 可以用来修改启动服务的默认端口：ng server --port 4201
2.3.3、ng test使用karma , jasmine进行测试
2.3.4、ng build  打包好处，将分散的文件进行梳理合并，减少请求数量和体积
打包完成之后查看打包后文件大小 ： du -h dist/
ng2中特有的优化方式：预编译技术 （aot） ng build --aot
打包时进一步优化，以生产模式进行打包： ng build -prod 打包之后的文件会被合并，每个文件有一个哈希码（是为了cdn判断文件是否进行了更新）
2.3.5、ng generate（创建组件）
在命令行使用创建组件：ng generate component 组件名 
用命令行创建的组件会自动在app文件下的app.module.ts的declarations中进行注册
使用的时候在组件名文件加下的.ts文件里找到selector的值，然后在app文件夹下的app.component.hrml里面用<zujianming></zujianming>引入

还可以用ng generate servivce ....创建服务
二、typescript
TypeScript的主要特征之一是添加类型信息，也因此得名

三、ng2学习路程
3.1 组件
3.1.1 创建组件
  创建组件需要三步：
    1、从 @angular/core 引入 Component 装饰器
    2、创建一个类，并用 @Component 修饰
    3、在 @Component 中 ，设置selector、template 和 styles 等元数据
import { Component, OnInit, ElementRef } from '@angular/core';

@Component({ // 装饰器   在装饰器里面的参数就是八大核心中的元数据
              // 装饰器是ts提供的一种语法特性 用来修饰一个类
  // 元数据与装饰器的关联 如果我们只定义了一个类，ng2是不知道如何解释这个类的，而如果在这个
  // 类上加上了@Component装饰器 这个装饰器会在运行的时候把他的元数据参数通过某种方式注入到
  // 这个类里面，然后ng2就会识别出来这个类是一个组件  装饰器的作用就是赋予一个类更丰富的信息，
  // 这些信息就是元数据   在这里简单解释就是 装饰器通过元数据丰富了组件
  selector: 'app-demo',
  templateUrl: './demo.component.html',
  styleUrls: ['./demo.component.scss']
})
export class DemoComponent implements OnInit { // class类（es6）组件类
  name = ''; // 看其他人写法声明变量在constructor外部声明
  constructor(public elementRef: ElementRef) { // 使用构造注入的方式注入依赖对象
    this.name = 'Semlinker'; // 执行初始化操作
    // 依赖注入和初始化数据的任务交给constructor
  }
  // constructor() { } 是es6中class类的独有方法constructor(构造函数) 是类中的特殊方法，
  // 主要用来做初始化操作，在进行类实例化操作时，会被自动调用。
  // constructor 应用场景在ng2 中，构造函数一般用于依赖注入或执行一些简单的初始化操作。

  ngOnInit() { // 其中 ngOnInit 用于在 Angular 获取输入属性后初始化组件，
               // 该钩子方法会在第一次 ngOnChanges 之后被调用。另外需要
    // 注意的是 ngOnInit 钩子只会被调用一次ngOnInit 应用场景
    // 在项目开发中我们要尽量保持构造函数简单明了，让它只执行简单的数据初始化操作，
    // 因此我们会把其他的初始化操作放在 ngOnInit 钩子中去执行。如在组件获取输入属性之后，
    // 需执行组件初始化操作等。
  }
// 在 Angular 2 中 constructor 一般用于依赖注入或执行简单的数据初始化操作，
// ngOnInit 钩子主要用于执行组件的其它初始化操作或获取组件输入的属性值。
}
--------------------------------------------------------------------------------------------------------
constructor与ngOnInit区别：https://segmentfault.com/a/1190000008685752
--------------------------------------------------------------------------------------------------------

3.1.2 组件间数据传递
3.1.2.1  父组件向子组件传递参数
@Input()装饰器定义了一组可以从父组件传递的参数
父组件html：
<p>
  first works!{{name}}
  <app-first-child [pname]="sex"></app-first-child>
  <!--[pname]是在子组件中通过@input属性定义的一个存储变量pname-->
  <!--"sex"对应父组件中定义的变量名，想给pname传什么值就对应将变量名填入-->
  <!--这是链接父子组件的桥梁pname对应着子组件的变量 sex对应着父组件的变量-->
</p>
父组件js：
export class FirstComponent implements OnInit {
  sex: string;
  name = ' ';

  constructor() {
    this.name = 'parentName';
    this.sex = '女';
  }

  ngOnInit() {
  }

}
子组件html：
<p>
  first-child works!{{name}}{{pname}}
  <!--{{name}}{{pname}}依旧只是对应着该组件中的name pname变量-->
</p>

子组件js：
export class FirstChildComponent implements OnInit {
  name = ' ';
  @Input() pname: string;
  // @Input()注意这里有小括号 在这只相当于声明了一个变量pname，桥梁搭建是在[pname]="sex"
  constructor() {
    this.name = 'ChildName';
  }

  ngOnInit() {
  }

}
四、模块
4.1.1 模块是以相关的组件，指令，管道和服务的组合的机制，其可以与其他模块组合以创建应用程序。
