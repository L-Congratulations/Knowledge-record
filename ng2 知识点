一、以大漠穷秋的NiceFish为案例进行
1.1 将项目克隆下来并在本地运行（已经安装好了angular-cli）
1.克隆项目： git clone https://github.com/lzxb/vue-c...
2.安装nodejs
3.进入项目NiceFish目录 安装依赖： npm install（根据需求看是用cnpm还是npm安装）
4.启动服务： ng serve --prod --aot 
如果down下来的项目中angular-cli的版本和电脑中装的不一致需要把电脑中的cli卸载：npm uninstall -g angular-cli
然后重新安装 npm install -g @angular/cli
如果还是有问题就重新down一遍代码然后配置。因为有的时候可能存在文件依赖顺序。

2.3、cli常用技巧
2.3.1、cli默认不会创建路由，要想创建好的项目里面包含路由，需要在运行时输入：ng new demoname --routing
2.3.2、ng server 有个port 可以用来修改启动服务的默认端口：ng server --port 4201
2.3.3、ng test使用karma , jasmine进行测试
2.3.4、ng build  打包好处，将分散的文件进行梳理合并，减少请求数量和体积
打包完成之后查看打包后文件大小 ： du -h dist/
ng2中特有的优化方式：预编译技术 （aot） ng build --aot
打包时进一步优化，以生产模式进行打包： ng build -prod 打包之后的文件会被合并，每个文件有一个哈希码（是为了cdn判断文件是否进行了更新）
2.3.5、ng generate（创建组件）
在命令行使用创建组件：ng generate component 组件名 
用命令行创建的组件会自动在app文件下的app.module.ts的declarations中进行注册
使用的时候在组件名文件加下的.ts文件里找到selector的值，然后在app文件夹下的app.component.hrml里面用<zujianming></zujianming>引入

还可以用ng generate servivce ....创建服务
二、typescript
TypeScript的主要特征之一是添加类型信息，也因此得名

三、ng2学习路程
3.1 组件
3.1.1 创建组件
  创建组件需要三步：
    1、从 @angular/core 引入 Component 装饰器
    2、创建一个类，并用 @Component 修饰
    3、在 @Component 中 ，设置selector、template 和 styles 等元数据
import { Component, OnInit, ElementRef } from '@angular/core';

@Component({ // 装饰器   在装饰器里面的参数就是八大核心中的元数据
              // 装饰器是ts提供的一种语法特性 用来修饰一个类
  // 元数据与装饰器的关联 如果我们只定义了一个类，ng2是不知道如何解释这个类的，而如果在这个
  // 类上加上了@Component装饰器 这个装饰器会在运行的时候把他的元数据参数通过某种方式注入到
  // 这个类里面，然后ng2就会识别出来这个类是一个组件  装饰器的作用就是赋予一个类更丰富的信息，
  // 这些信息就是元数据   在这里简单解释就是 装饰器通过元数据丰富了组件
  selector: 'app-demo',
  templateUrl: './demo.component.html',
  styleUrls: ['./demo.component.scss']
})
export class DemoComponent implements OnInit { // class类（es6）组件类
  name = ''; // 看其他人写法声明变量在constructor外部声明
  constructor(public elementRef: ElementRef) { // 使用构造注入的方式注入依赖对象
    this.name = 'Semlinker'; // 执行初始化操作
    // 依赖注入和初始化数据的任务交给constructor
  }
  // constructor() { } 是es6中class类的独有方法constructor(构造函数) 是类中的特殊方法，
  // 主要用来做初始化操作，在进行类实例化操作时，会被自动调用。
  // constructor 应用场景在ng2 中，构造函数一般用于依赖注入或执行一些简单的初始化操作。

  ngOnInit() { // 其中 ngOnInit 用于在 Angular 获取输入属性后初始化组件，
               // 该钩子方法会在第一次 ngOnChanges 之后被调用。另外需要
    // 注意的是 ngOnInit 钩子只会被调用一次ngOnInit 应用场景
    // 在项目开发中我们要尽量保持构造函数简单明了，让它只执行简单的数据初始化操作，
    // 因此我们会把其他的初始化操作放在 ngOnInit 钩子中去执行。如在组件获取输入属性之后，
    // 需执行组件初始化操作等。
  }
// 在 Angular 2 中 constructor 一般用于依赖注入或执行简单的数据初始化操作，
// ngOnInit 钩子主要用于执行组件的其它初始化操作或获取组件输入的属性值。
}
--------------------------------------------------------------------------------------------------------
constructor与ngOnInit区别：https://segmentfault.com/a/1190000008685752
--------------------------------------------------------------------------------------------------------

3.1.2 组件间数据传递

3.1.2.1  父组件向子组件传递参数
@Input()装饰器定义了一组可以从父组件传递的参数
父组件html：
<p>
  first works!{{name}}
  <app-first-child [pname]="sex"></app-first-child>
  <!--[pname]是在子组件中通过@input属性定义的一个存储变量pname-->
  <!--"sex"对应父组件中定义的变量名，想给pname传什么值就对应将变量名填入-->
  <!--这是链接父子组件的桥梁pname对应着子组件的变量 sex对应着父组件的变量-->
</p>
父组件js：
export class FirstComponent implements OnInit {
  sex: string;
  name = ' ';

  constructor() {
    this.name = 'parentName';
    this.sex = '女';
  }

  ngOnInit() {
  }

}
子组件html：
<p>
  first-child works!{{name}}{{pname}}
  <!--{{name}}{{pname}}依旧只是对应着该组件中的name pname变量-->
</p>

子组件js：
export class FirstChildComponent implements OnInit {
  name = ' ';
  @Input() pname: string;
  // @Input()注意这里有小括号 在这只相当于声明了一个变量pname，桥梁搭建是在[pname]="sex"
  constructor() {
    this.name = 'ChildName';
  }

  ngOnInit() {
  }

}
-----------------------------------------------------------------------------------------------------------------
父组件向子组件传递参数:
利用“属性绑定”来搭建桥梁<app-first-child [pname]="sex"></app-first-child>
然后只需要在需要引入父组件信息的子组件中利用@Input() pname: string;定义一个存储数据的变量pname，其他地方不需要变动
引用父组件数据的时候直接用正常使用变量的方式调用{{panme}}

-----------------------------------------------------------------------------------------------------------------

3.1.2.2 父组件监听子组件变化（子组件传递数据给父组件）
子组件js:
export class FirstChildComponent implements OnInit { 
  @Output() change = new EventEmitter<number>();
  // 使用装饰器@Output修饰了change属性，并为其赋了初值为EventEmitter的实例；
  // count = 0; count变量可以直接在本地定义也可以从父组件获取
  @Input() count: number;  
  constructor() {}
  increaseNum() {
    this.count ++;
    this.change.emit(this.count);
    // 在increaseNumber和descreaseNumber方法修改了count属性后，
    // 调用了change属性的emit方法通知父组件。
  }
  descreaseNum() {
    this.count --;
    this.change.emit(this.count);
  }
  ngOnInit() {
  }

}
子组件html：
<p>
  Count:{{count}}
  <!--{{name}}{{pname}}依旧只是对应着该组件中的name pname变量-->
</p>
<button (click)="increaseNum()">+</button>
<button (click)="descreaseNum()">-</button>
父组件js：
export class FirstComponent implements OnInit { 
  caseCount = 10;
  // 定义并初始化一个变量用来接收从子组件传递过来的数据
  constructor() {    
  }
  countChange($event) {
    // 通过桥梁与子组件的chang建立联系，并把值此处的$event就相当于
    // this.change.emit(this.count);中的this.count 并把传递过来的值保存到本组件中
    this.caseCount = $event;
  }
  ngOnInit() {
  }

}
父组件html：
<p>
  parentNum{{caseCount}}
  <app-first-child [count]="caseCount" (change)="countChange($event)"></app-first-child>
  <!--通过(change)="countChange($event)"把子组件的chang与父组件的countChange进行桥梁链接
  $event接收的就是传递的数据--> 
</p>
-----------------------------------------------------------------------------------------------------------------------
父组件监听子组件变化（子组件传递数据给父组件）：
1、首先在子组件中借助@Output    change = new EventEmitter();初始化一个chang属性
2、然后建立一个触发事件 
increaseNum() {
    this.count ++;
    this.change.emit(this.count);
    // 在increaseNumber和descreaseNumber方法修改了count属性后，
    // 调用了change属性的emit方法通知父组件。
 }
通过chang属性的emit方法把想要传递的数据告诉父组件
3、子组件父组件通过
<app-first-child (change)="countChange($event)"></app-first-child>
建立桥梁连接 此时父组件的countChange方法会接收到子组件传递的数据，数据就存储在$event参数中
4、在父组件中处理取到的子组件数据
caseCount = 10;  // 定义并初始化一个变量用来接收从子组件传递过来的数据
countChange($event) {
    // 通过桥梁与子组件的chang建立联系，并把值此处的$event就相当于
    // this.change.emit(this.count);中的this.count 并把传递过来的值保存到本组件中
    this.caseCount = $event;
  }
-----------------------------------------------------------------------------------------------------------------------

3.1.2.3 双向数据绑定
其实上面我们模拟了“双向数据绑定”：父组件将数据传入子组件，子组件改变数据时通知父组件进行“同步更新”。但是要注意其实数据流向是单向的，
即数据是父组件单向流入子组件，父组件数据的更新是通过子组件的事件通知以后才被更新。
也就是说其实在Angular 2中：双向数据绑定 = 单向数据绑定 + 事件



四、模块
4.1.1 模块是以相关的组件，指令，管道和服务的组合的机制，其可以与其他模块组合以创建应用程序。
模块的基本使用 为了能够定义模块，我们必须使用装饰器 NgModule。
import { NgModule } from '@angular/core';

@NgModule({
  imports: [ ... ],
  declarations: [ ... ],
  bootstrap: [ ... ]
})
export class AppModule { }
在上面的例子中，我们已经将类AppModule转换为Angular 2模块，只需使用NgModule装饰器。 
NgModule装饰器至少需要三个属性：import，declarations和bootstrap
