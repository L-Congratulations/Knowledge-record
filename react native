一、安装：
npm install -g reacr-native-cli
安装androidstutio

二、创建第一个项目：
在命令行中：react-native init firstapp
打开android模拟器或者连上android设备。在命令行中：react-native run-android 运行第一个reactnative项目

三、react
安装react脚手架工具：
npm install -g create-react-app

启动react：npm start
3.1、创建组件：
调用react的createClass的方法来创建一个组件。组件首字母要大写。
let HelloMessage = React.createClass ({
    render:function () {
        return(
            <h1>Hello world</h1> // 意组件类只能包含一个顶层标签，否则也会报错。
        )
    }
})
然后利用ReactDOM.render（）方法将组件渲染到dom中。
ReactDOM.render(<HelloMessage/>, document.querySelector('#root1'));

React.createClass 方法用于生成一个组件类 HelloMessage。
<HelloMessage /> 实例组件类并输出信息。

3.2、组件属性
注意，在添加属性时， class 属性需要写成 className ，for 属性需要写成 htmlFor ，这是因为 class 和 for 是 JavaScript 的保留字。
如果我们需要向组件传递参数，可以使用 this.props 对象,实例如下：
var HelloMessage = React.createClass({
  render: function() {
    return <h1>Hello {this.props.name}</h1>;
  }
});
 
ReactDOM.render(
  <HelloMessage name="Runoob" />,
  document.getElementById('example')
);
以上实例中 name 属性通过 this.props.name 来获取。

3.3、复合组件：
我们可以通过创建多个组件来合成一个组件，即把组件的不同功能点进行分离。
let Name = React.createClass({
    render:function () {
        return(
            <h2>{this.props.name}</h2>
        )
    }
});

let Link = React.createClass({
    render:function () {
        return(
            <a href={this.props.site}>{this.props.site}</a>
        )
    }
});

let Web = React.createClass({
    render:function () {
        return(
            <div>
                <Name name={this.props.name} />
                <Link site={this.props.site} />
            </div>

        )
    }
});
ReactDOM.render(<Web name="菜鸟教程" site="http://www.runoob.com"/>,document.querySelector('#root2'));

3.4、React State(状态)
React 把组件看成是一个状态机（State Machines）。通过与用户的交互，实现不同状态，然后渲染 UI，让用户界面和数据保持一致。
React 里，只需更新组件的 state，然后根据新的 state 重新渲染用户界面（不要操作 DOM）。

3.5、组件声明周期
react components整个声明周期在浏览器中存在的三个状态
mounted：react component 被render解析生成对应的dom节点，并插入浏览器的dom结构的一个过程。// 把代码解析并插入浏览器dom结构，从无到有的完整过程。
update：已经渲染好的组件被重新render的过程。dom结构不一定会发生改变，react会比较新旧state，只有state确实发生改变并且影响到dom结构的时候才去改变
        对应的dom结构。   // 第二次渲染
unmounted：已经渲染好的component被从dom结构中移除的过程。  //将渲染过的dom移除    

每一个状态react都封装了对应的钩子函数
3.5.1、mounting中的钩子函数：（在第一次将代码渲染成dom的整个生命周期中）
每个状态里面都包含will和did（除了unmounting，他只包含移除dom节点之前的状态，节点移除之后就结束了）。will是进入该状态前的时间节点，did是该状态结束
之后的时间节点。我们在实际开发中很少调用updating和unmounting的钩子函数，因此重点了解记住mounting中所包含的钩子函数：


state和props区别？？？？？




3.5.2、updating、和unmounting两个状态，里面的钩子函数在实际工作中很少用到。先不去重点了解。

3.6、react事件监听：
react通过onClick，onChang等驼峰式命名来绑定事件：<button onClick={this.handleClick}>显示|隐藏</button>

拿到render函数中的某个标签：通过给标签定义一个ref属性，来给子组件起一个名字，然后通过this.refs.name来索引到子组件
<span ref='tip'>测试内容</span>   console.log(this.refs.tip) 通过这种方式拿到的是render函数中的节点，
要想操作真实的dom还需要使用react提供的let tipE = ReactDOM.findDOMNode(this.refs.tip);
然后就可以操作
if (tipE.style.display === 'none'){
            tipE.style.display = 'inline'
        }else {
            tipE.style.display = 'none'
        }
        <span ref='tip'>测试内容</span>
        
onChang事件：
let TestInputComponent = React.createClass({
    handleChange:function (event) {
        this.setState({
            inputContent:event.target.value
        });
        event.preventDefault();
        event.stopPropagation();
    },
    getInitialState:function () {
      return {
          inputContent:''
      }
    },
    render:function () {
        return(
            <div>
                <input onChange={this.handleChange} type="text" />
                <span>{this.state.inputContent}</span>
            </div>
        )
    }
})


五、react实战开发：
5.1、打包的时候把引用的库和自己写的逻辑代码分成两个js包进行打包，这样在用户更新的时候只需要更新逻辑代码的js包就行，因为引用的外部库几乎不会进行改动。
缓存是根据文件命中md5的戳来进行更新的，每次代码改动然后重新编译的时候文件命中md5的戳就会改变，这样就会加载新的js文件。

5.2、在工作中做一些项目的时候，应该在项目根目录下新建一个文件夹docs，在文件夹里面新建一个README.md文件，来记录项目中的一些东西。
软件三要素：程序、数据、文档

5.3、在npm安装文件时--save和--save-dev的区别：
--save安装的文件是开发和上线都需要依赖的文件如react.js
--save-dev安装的是在开发的时候所需要依赖的工具，在上线之后是不需要的，如webpack。
而node_moduls中的文件也是开发时需要的文件和需要文件依赖的一系列文件，在打包上线时也是不需要的

5.4、项目文件代码分离的层级划分：
在src文件夹下，第一层是页面层，也就是每个文件夹都是一个页面，并列为src子目录。
每个页面的文件夹展开后都有一个index.jsx就是这个页面的入口文件，如果比较简单可以直接写在index里面，如果页面比较复杂，由多个模块或组件组成，
就需要把页面进行拆分，放到一个与index同级目录下的subpage文件夹里面。该文件夹下的子页面是只属于该页面的。不与其他页面共有。
src下新建components文件夹，（存放共用的组件，通用的组件，不是专属于某个页面的组件）里面存放的是组件，如Header文件夹。
Header文件夹下有一个index.jsx文件是入口文件

5.5、props
组件标签中：<Web name="菜鸟教程" site="http://www.runoob.com"/> // 在定义的属性中不仅可以传递字符串也可以传递其他，如对象：
var obj={a:'sss',b:'ddd'}
<Web name="菜鸟教程" site={obj}/>
<a href={this.props.site}>{this.props.site.a}</a>
在组件实例中：<a href={this.props.site}>{this.props.site}</a>
在定义组件实例中可以通过this.props..来获取标签中的属性
react中，props一般只作为父组件给子组件传递数据用。不要试图去修改props。定义好了之后只能去引用，不能在子组件中去修改props的值。

5.6、state
如果组件内部自身的属性发生变化，需要用state
react会实时监听每个组件的props和state值，一旦变化会立刻更新组件，将结果重新渲染到页面上。
改变sate必须要调用setState()方法。不能直接赋值。

5.7、智能组件和木偶组件
在src目录下：
containers文件里面装的是页面。是智能组件，接受数据并处理，然后把结果下发到木偶组件去执行
components文件夹里面装的是组件。是木偶组件，被动接收，不关心操作的具体内容。在组件里面不允许有数据调用（ajax），为了在别的地方调用的时候不会发生冲突，
尽量降低耦合度，提高组件的复用性。

5.8、常用声明周期
在render函数中渲染数组：
<ul>
                    arr.length === 0
                    ? <p>loading...</p>
                    : {arr.map(function (item,index) { return})}
                </ul>
页面在初次渲染的时候是直接渲染的loading。。。，因为数据请求是异步的，在渲染的时候数据还没请求回来。
数据请求是在页面渲染完了之后请求的，也就是在钩子函数componentDidMount()中进行请求的。
ajax请求完成之后通过setState()方法来修改arr的值，然后react会再次触发视图更新渲染视图，将数据渲染到dom
 componentDidMount:function () {
        // ajax请求
        // setState
    }
componentDidUpdate:function () {
        // 组件重新渲染完毕之后的钩子一般用来清空并更新数据。实际开发项目时会经常用到
    }
componentWillUnmount:function () {
        // 组件销毁前的钩子，一般用于存储一些特殊信息，清理setTimeout事件等
    }
    
    
六、react性能优化
6.1、性能检测
首先安装检测工具：npm install react-addons-perf --save
然后在src下的入口文件index.jsx里面写入如下代码：
import Perf from 'react-addons-perf'
if(__DEV__){
window.Pref = Pref
}
然后将程序运行起来，在浏览器console窗口输入Perf.start(),操作页面内的交互操作完成后再console窗口输入Perf.stop()再输入Pref.printWasted()
就会打出操作的每一步所使用的时间。
判断依据：如果每次操作的时间在十几毫秒之内就不需要再去优化

6.2、PureRenderMixin优化：该方法可以去判断是否需要react重新渲染，避免了重新渲染浪费时间
react最基本的优化方式是使用PureRenderMixin，安装工具：
npm i react-addons-pure-render-mixin --save
然后在组件中使用,在创建组件时候加入（每个组件都需要这样做）：
constructor(props,context){
this.shouldComponentUpdate = PureRenderMixin.shouldComponentUpdate.bind(this);
}
在组件重新render的时候调用该方法去判断该组件是否真的需要重新render

6.3、immutable.js优化
React终极优化是使用immutable.js来处理数据。
当我们组件的props和state中的数据结构层次不深的时候，就没有必要使用它。如果数据结构
层次很深（如：obj.x.y.a.b=10），就需要考虑使用。
不轻易使用是因为immutable定义了一种新的操作数据的语法，和js数据操作完全不一样，如果每个地方都
都这样用，学习成本和风险很高

七、react-router
7.1、首先安装react-router ：npm install react-router --save


八、reducx
8.1、安装：npm i redux --save
在react中使用redux肯定会用到react-redux这一工具，因此还需要安装：
mpm i react-redux --save

步骤：
定制规则
根据规则生成store
订阅数据，及state变化之后的派发规则。通过 store.getState()拿到store中state数据
触发数据变化，通过store.dispath()来修改store中的数据

8.2、react和redux集成

