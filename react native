一、安装：
npm install -g reacr-native-cli
安装androidstutio

二、创建第一个项目：
在命令行中：react-native init firstapp
打开android模拟器或者连上android设备。在命令行中：react-native run-android 运行第一个reactnative项目

三、react
安装react脚手架工具：
npm install -g create-react-app

启动react：npm start
3.1、创建组件：
调用react的createClass的方法来创建一个组件。组件首字母要大写。
let HelloMessage = React.createClass ({
    render:function () {
        return(
            <h1>Hello world</h1> // 意组件类只能包含一个顶层标签，否则也会报错。
        )
    }
})
然后利用ReactDOM.render（）方法将组件渲染到dom中。
ReactDOM.render(<HelloMessage/>, document.querySelector('#root1'));

React.createClass 方法用于生成一个组件类 HelloMessage。
<HelloMessage /> 实例组件类并输出信息。

3.2、组件属性
注意，在添加属性时， class 属性需要写成 className ，for 属性需要写成 htmlFor ，这是因为 class 和 for 是 JavaScript 的保留字。
如果我们需要向组件传递参数，可以使用 this.props 对象,实例如下：
var HelloMessage = React.createClass({
  render: function() {
    return <h1>Hello {this.props.name}</h1>;
  }
});
 
ReactDOM.render(
  <HelloMessage name="Runoob" />,
  document.getElementById('example')
);
以上实例中 name 属性通过 this.props.name 来获取。

3.3、复合组件：
我们可以通过创建多个组件来合成一个组件，即把组件的不同功能点进行分离。
let Name = React.createClass({
    render:function () {
        return(
            <h2>{this.props.name}</h2>
        )
    }
});

let Link = React.createClass({
    render:function () {
        return(
            <a href={this.props.site}>{this.props.site}</a>
        )
    }
});

let Web = React.createClass({
    render:function () {
        return(
            <div>
                <Name name={this.props.name} />
                <Link site={this.props.site} />
            </div>

        )
    }
});
ReactDOM.render(<Web name="菜鸟教程" site="http://www.runoob.com"/>,document.querySelector('#root2'));

3.4、React State(状态)
React 把组件看成是一个状态机（State Machines）。通过与用户的交互，实现不同状态，然后渲染 UI，让用户界面和数据保持一致。
React 里，只需更新组件的 state，然后根据新的 state 重新渲染用户界面（不要操作 DOM）。

3.5、组件声明周期
react components整个声明周期在浏览器中存在的三个状态
mounted：react component 被render解析生成对应的dom节点，并插入浏览器的dom结构的一个过程。// 把代码解析并插入浏览器dom结构，从无到有的完整过程。
update：已经渲染好的组件被重新render的过程。dom结构不一定会发生改变，react会比较新旧state，只有state确实发生改变并且影响到dom结构的时候才去改变
        对应的dom结构。   // 第二次渲染
unmounted：已经渲染好的component被从dom结构中移除的过程。  //将渲染过的dom移除    

每一个状态react都封装了对应的钩子函数
3.5.1、mounting中的钩子函数：（在第一次将代码渲染成dom的整个生命周期中）
每个状态里面都包含will和did（除了unmounting，他只包含移除dom节点之前的状态，节点移除之后就结束了）。will是进入该状态前的时间节点，did是该状态结束
之后的时间节点。我们在实际开发中很少调用updating和unmounting的钩子函数，因此重点了解记住mounting中所包含的钩子函数：


state和props区别？？？？？




3.5.2、updating、和unmounting两个状态，里面的钩子函数在实际工作中很少用到。先不去重点了解。

3.6、react事件监听：
react通过onClick，onChang等驼峰式命名来绑定事件：<button onClick={this.handleClick}>显示|隐藏</button>

拿到render函数中的某个标签：通过给标签定义一个ref属性，来给子组件起一个名字，然后通过this.refs.name来索引到子组件
<span ref='tip'>测试内容</span>   console.log(this.refs.tip) 通过这种方式拿到的是render函数中的节点，
要想操作真实的dom还需要使用react提供的let tipE = ReactDOM.findDOMNode(this.refs.tip);
然后就可以操作
if (tipE.style.display === 'none'){
            tipE.style.display = 'inline'
        }else {
            tipE.style.display = 'none'
        }
        <span ref='tip'>测试内容</span>
        
onChang事件：
let TestInputComponent = React.createClass({
    handleChange:function (event) {
        this.setState({
            inputContent:event.target.value
        });
        event.preventDefault();
        event.stopPropagation();
    },
    getInitialState:function () {
      return {
          inputContent:''
      }
    },
    render:function () {
        return(
            <div>
                <input onChange={this.handleChange} type="text" />
                <span>{this.state.inputContent}</span>
            </div>
        )
    }
})
