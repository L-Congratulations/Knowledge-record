一、let和const命令
let是对变量的声明，const是对常量的声明
0、const一旦声明变量，就必须立即初始化，不能留到以后赋值。
1、仅在块级作用域内有效
2、声明的变量一定要在声明后使用，否则报错。
3、暂时性死区
    只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。
    var tmp = 123;
    if (true) {
      tmp = 'abc'; // ReferenceError
      let tmp;
    }
 4、let不允许在相同作用域内，重复声明同一个变量。
    // 报错
    function () {
      let a = 10;
      var a = 1;
    }
    // 报错
    function () {
      let a = 10;
      let a = 1;
    }
 5、let实际上为 JavaScript 新增了块级作用域。
    function f1() {
      let n = 5;
      if (true) {
        let n = 10;
      }
      console.log(n); // 5
    }
    上面的函数有两个代码块，都声明了变量n，运行后输出5。这表示外层代码块不受内层代码块的影响。如果两次都使用var定义变量n，最后输出的值才是10。
    ES6 允许块级作用域的任意嵌套。
    {{{{{let insane = 'Hello World'}}}}};
    上面代码使用了一个五层的块级作用域。外层作用域无法读取内层作用域的变量。
    {{{{
      {let insane = 'Hello World'}
      console.log(insane); // 报错
    }}}};   
二、do 表达式
本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。

{
  let t = f();
  t = t * t + 1;
}
上面代码中，块级作用域将两个语句封装在一起。但是，在块级作用域以外，没有办法得到t的值，因为块级作用域不返回值，除非t是全局变量。

现在有一个提案，使得块级作用域可以变为表达式，也就是说可以返回值，办法就是在块级作用域之前加上do，使它变为do表达式。

let x = do {
  let t = f();
  t * t + 1;
};
上面代码中，变量x会得到整个块级作用域的返回值。
