flex布局：
水平垂直居中：在父级上设置flex 主轴和侧轴都设为center
#dad {
    display: flex;
    justify-content: center;
    align-items: center
}
-------------------------------------------------------------------------------------------------------------------------------------
浏览器缓存优化：
按需加载
综合各种缓存机制比较，对于静态文件，如JS、CSS、字体、图片等，适合通过浏览器缓存机制来进行缓存，通过缓存文件可大幅提升Web的加载速度，
且节省流量。但也有一些不足：缓存文件需要首次加载后才会产生；浏览器缓存的存储空间有限，缓存有被清除的可能；缓存的文件没有校验。
要解决这些不足，可以参考手 Q 的离线包，它有效的解决了这些不足。

对于Web在本地或服务器获取的数据，可以通过Dom Storage和IndexedDB进行缓存。也在一定程度上减少和Server的交互，提高加载速度，同时节省流量。

在实际应用中，为了解决Cache-Control缓存时长不好设置的问题，以及为了“消灭304”，Web前端采用的方式是：
在要缓存的资源文件名中加上版本号或文件MD5值字串，如common.d5d02a02.js、common.v1.js，同时设置Cache-Control:max-age=31536000，
也就是一年。在一年时间内，资源文件如果本地有缓存，就会使用缓存；也就不会有304的回包。
如果资源文件有修改，则更新文件内容，同时修改资源文件名，如common.v2.js，html页面也会引用新的资源文件名。
通过这种方式，实现了：缓存文件没有更新，则使用缓存；缓存文件有更新，则第一时间使用最新文件的目的
----------------------------------------------------------------------------------------------------------------------------------
手机真机调试：
1、在Android设备上安装Chrome浏览器
2、电脑上安装对应的Android设备驱动
3、在电脑上输入 chrome://inspect进行配置并调试

------------------------------------------------------------------------------------------------------------------------------------

DOM操作：

document.createElement(eName);创建一个节点

document.createAttribute(attrName);对某个节点创建属性

document.createTextNode(text);创建文本节点

3.添加节点
document.insertBefore(newNode,referenceChild);在某个节点前插入节点

parentNode.appendChild(newNode);给某个节点添加子节点
cloneNode(true | false);复制某个节点
参数：是否复制原节点的所有属性

5.删除节点
parentNode.removeChild(node)删除某个节点的子节点

修改文本节点
appendData(data);将data加到文本节点后面

deleteData(start,length);将从start处删除length个字符

insertData(start,data)在start处插入字符,start的开始值是0;

replaceData(start,length,data)在start处用data替换length个字符

splitData(offset)在offset处分割文本节点

substringData(start,length)从start处提取length个字符

属性操作
getAttribute(name)通过属性名称获取某个节点属性的值

setAttribute(name,value);修改某个节点属性的值

removeAttribute(name)删除某个属性

替换节点 方法replace(new,old)

------------------------------------------------------------------------------------------------------------------------------
json转化
 Object.toJSONString()，而后者变成了 String.parseJSON()
 -----------------------------------------------------------------------------------------------------------------------------
jsonp原理：
利用<script>标签没有跨域限制的“漏洞”（历史遗迹啊）来达到与第三方通讯的目的。当需要通讯时，本站脚本创建一个<script>元素，
地址指向第三方的API网址，形如：     <script src="http://www.example.net/api?param1=1&param2=2"></script>    
并提供一个回调函数来接收数据（函数名可约定，或通过地址参数传递）。     第三方产生的响应为json数据的包装（故称之为jsonp，
即json padding），形如：     callback({"name":"hax","gender":"Male"})     这样浏览器会调用callback函数，
并传递解析后json对象作为参数。本站脚本可在callback函数里处理所传入的数据。


浏览器读取到script标签后执行里面的链接，调用远程的js代码，然后本地通过使用同名函数来获取到远程js代码中的数据。

http://www.cnblogs.com/dowinning/archive/2012/04/19/json-jsonp-jquery.html
------------------------------------------------------------------------------------------------------------------------------
闭包：
闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。
防止内存泄漏：
由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。
解决方法是，在退出函数之前，将不使用的局部变量全部删除。

-------------------------------------------------------------------------------------------------------------------------------
面向对象：
“对象”是一个容器，封装了“属性”（property）和“方法”（method）。
1、易维护
采用面向对象思想设计的结构，可读性高，由于继承的存在，即使改变需求，那么维护也只是在局部模块，所以维护起来是非常方便和较低成本的。
2、质量高
在设计时，可重用现有的，在以前的项目的领域中已被测试过的类使系统满足业务需求并具有较高的质量。
3、效率高
在软件开发时，根据设计的需要对现实世界的事物进行抽象，产生类。使用这样的方法解决问题，接近于日常生活和自然的思考方式，势必提高软件开发的效率和质量。
4、易扩展
由于继承、封装、多态的特性，自然设计出高内聚、低耦合的系统结构，使得系统更灵活、更容易扩展，而且成本较低。



-----------------------------------------------------------------------------------------------------------------------------
JavaScript有三种方法，可以确定一个值到底是什么类型。
typeof运算符
instanceof运算符
Object.prototype.toString方法

typeof可以判断：基本类型可以直接判断出来。
数值、字符串、布尔值分别返回number、string、boolean、函数返回function。
undefined返回undefined。利用这一点，typeof可以用来检查一个没有声明的变量，而不报错。
// 正确的写法
if (typeof v === "undefined") {
  // ...
}
除此以外，其他情况都返回object。
既然typeof对数组（array）和对象（object）的显示结果都是object，那么怎么区分它们呢？instanceof运算符可以做到。

var o = {};
var a = [];

o instanceof Array // false
a instanceof Array // true
-----------------------------------------------------------------------------------------------------------------------------
字符串：
不过，由于字符串是只读的，那些会改变原数组的方法，比如push()、sort()、reverse()、splice()都对字符串无效，
只有将字符串显式转为数组后才能使用，参见《标准库》一章的数组部分。
-----------------------------------------------------------------------------------------------------------------------------
对象：
JavaScript规定，如果行首是大括号，一律解释为语句（即代码块）。如果要解释为表达式（即对象），必须在大括号前加上圆括号。

({ foo: 123})
这种差异在eval语句中反映得最明显。

eval('{foo: 123}') // 123
eval('({foo: 123})') // {foo: 123}
上面代码中，如果没有圆括号，eval将其理解为一个代码块；加上圆括号以后，就理解成一个对象

上面代码分别采用点运算符和方括号运算符，读取属性p。

请注意，如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。但是，数字键可以不加引号，因为会被当作字符串处理。

var o = {
  0.7: 'Hello World'
};

o['0.7'] // "Hello World"
o[0.7] // "Hello World"
方括号运算符内部可以使用表达式。

o['hello' + ' world']
o[3 + 3]
数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符。

读取属性全用【】运算符更好

查看一个对象本身的所有属性，可以使用Object.keys方法。

var o = {
  key1: 1,
  key2: 2
};

Object.keys(o);
// ['key1', 'key2']


delete命令用于删除对象的属性，删除成功后返回true。

var o = {p: 1};
Object.keys(o) // ["p"]

delete o.p // true
o.p // undefined
Object.keys(o) // []
上面代码中，delete命令删除o对象的p属性。删除后，再读取p属性就会返回undefined，而且Object.keys方法的返回值中，o对象也不再包括该属性。

注意，删除一个不存在的属性，delete不报错，而且返回true。

var o = {};
delete o.p // true
上面代码中，o对象并没有p属性，但是delete命令照样返回true。因此，不能根据delete命令的结果，认定某个属性是存在的，
只能保证读取这个属性肯定得到undefined。

只有一种情况，delete命令会返回false，那就是该属性存在，且不得删除。

var o = Object.defineProperty({}, 'p', {
  value: 123,
  configurable: false
});

o.p // 123
delete o.p // false
另外，需要注意的是，delete命令只能删除对象本身的属性，无法删除继承的属性

in运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回true，否则返回false。
// 假设变量x未定义

// 写法一：报错
if (x) { return 1; }

// 写法二：不正确
if (window.x) { return 1; }

// 写法三：正确
if ('x' in window) { return 1; }
上面三种写法之中，如果x不存在，第一种写法会报错；如果x的值对应布尔值false（比如x等于空字符串），第二种写法无法得到正确结果；只有第三种写法，
才能正确判断变量x是否存在。

in运算符的一个问题是，它不能识别对象继承的属性。
-----------------------------------------------------------------------------------------------------------------------------
数组：
toString方法返回数组的字符串形式。

var a = [1, 2, 3];
a.toString() // "1,2,3"

push方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。

var a = [];

a.push(1) // 1
a.push('a') // 2


indexOf方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。

var a = ['a', 'b', 'c'];

a.indexOf('b') // 1
a.indexOf('y') // -1
indexOf方法还可以接受第二个参数，表示搜索的开始位置。

['a', 'b', 'c'].indexOf('a', 1) // -1
上面代码从1号位置开始搜索字符a，结果为-1，表示没有搜索到。

lastIndexOf方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。

reduce方法和reduceRight方法依次处理数组的每个成员，最终累计为一个值。

它们的差别是，reduce是从左到右处理（从第一个成员到最后一个成员），reduceRight则是从右到左（从最后一个成员到第一个成员），其他完全一样。

这两个方法的第一个参数都是一个函数。该函数接受以下四个参数。

累积变量，默认为数组的第一个成员
当前变量，默认为数组的第二个成员
当前位置（从0开始）
原数组
这四个参数之中，只有前两个是必须的，后两个则是可选的。

下面的例子求数组成员之和。

[1, 2, 3, 4, 5].reduce(function(x, y){
  console.log(x, y)
  return x + y;
});
// 1 2
// 3 3
// 6 4
// 10 5
//最后结果：15
上面代码中，第一轮执行，x是数组的第一个成员，y是数组的第二个成员。从第二轮开始，x为上一轮的返回值，y为当前数组成员，
直到遍历完所有成员，返回最后一轮计算后的x。

利用reduce方法，可以写一个数组求和的sum方法。

Array.prototype.sum = function (){
  return this.reduce(function (partial, value) {
    return partial + value;
  })
};

[3, 4, 5, 6, 10].sum()
// 28
如果要对累积变量指定初值，可以把它放在reduce方法和reduceRight方法的第二个参数。

[1, 2, 3, 4, 5].reduce(function(x, y){
  return x + y;
}, 10);
// 25
上面代码指定参数x的初值为10，所以数组从10开始累加，最终结果为25。注意，这时y是从数组的第一个成员开始遍历。

filter方法的参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。

[1, 2, 3, 4, 5].filter(function (elem) {
  return (elem > 3);
})
// [4, 5]

map方法对数组的所有成员依次调用一个函数，根据函数结果返回一个新数组。

slice方法用于提取原数组的一部分，返回一个新数组，原数组不变。

它的第一个参数为起始位置（从0开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。
如果slice方法的参数是负数，则表示倒数计算的位置。

var a = ['a', 'b', 'c'];
a.slice(-2) // ["b", "c"]
a.slice(-2, -1) // ["b"]
上面代码中，-2表示倒数计算的第二个位置，-1表示倒数计算的第一个位置。

如果参数值大于数组成员的个数，或者第二个参数小于第一个参数，则返回空数组。

var a = ['a', 'b', 'c'];
a.slice(4) // []
a.slice(2, 1) // []
slice方法的一个重要应用，是将类似数组的对象转为真正的数组。

Array.prototype.slice.call({ 0: 'a', 1: 'b', length: 2 })
// ['a', 'b']

Array.prototype.slice.call(document.querySelectorAll("div"));
Array.prototype.slice.call(arguments);
上面代码的参数都不是数组，但是通过call方法，在它们上面调用slice方法，就可以把它们转为真正的数组。

reverse方法用于颠倒数组中元素的顺序，返回改变后的数组。注意，该方法将改变原数组。
----------------------------------------------------------------------------------------------------------------------------
浏览器环境：
为了解决脚本文件下载阻塞网页渲染的问题，一个方法是加入defer属性。

<script src="a.js" defer></script>
<script src="b.js" defer></script>
上面代码中，只有等到DOM加载完成后，才会执行a.js和b.js。

defer的运行流程如下。

浏览器开始解析HTML网页
解析过程中，发现带有defer属性的script标签
浏览器继续往下解析HTML网页，同时并行下载script标签中的外部脚本
浏览器完成解析HTML网页，此时再执行下载的脚本
有了defer属性，浏览器下载脚本文件的时候，不会阻塞页面渲染。下载的脚本文件在DOMContentLoaded事件触发前执行（即刚刚读取完</html>标签）
，而且可以保证执行顺序就是它们在页面上出现的顺序。

async属性的作用是，使用另一个进程下载脚本，下载时不会阻塞渲染。

浏览器开始解析HTML网页
解析过程中，发现带有async属性的script标签
浏览器继续往下解析HTML网页，同时并行下载script标签中的外部脚本
脚本下载完成，浏览器暂停解析HTML网页，开始执行下载的脚本
脚本执行完毕，浏览器恢复解析HTML网页
async属性可以保证脚本下载的同时，浏览器继续渲染。需要注意的是，一旦采用这个属性，就无法保证脚本的执行顺序。哪个脚本先下载结束，就先执行那个脚本。
另外，使用async属性的脚本文件中，不应该使用document.write方法。

为了防止攻击者篡改外部脚本，script标签允许设置一个integrity属性，写入该外部脚本的Hash签名，用来验证脚本的一致性。

<script src="/assets/application.js"
  integrity="sha256-TvVUHzSfftWg1rcfL6TIJ0XKEGrgLyEq6lEpcmrG9qs=">
</script>
上面代码中，script标签有一个integrity属性，指定了外部脚本/assets/application.js的SHA265签名。一旦有人改了这个脚本，
导致SHA265签名不匹配，浏览器就会拒绝加载。
----------------------------------------------------------------------------------------------------------------------------

一、变量作用域和闭包：
1、闭包的理解：子函数可以使用父函数的局部变量
          function aa() {//父函数
            var a = 12;
            function bb() {//子函数
                alert(a);//子函数可以使用父函数的局部变量
            }
            bb();
        }
二、运算符：
1、取余：%
----------------------------------------------------------------------------------------------------------------------------------
  做隔行变色：
  var list = document.querySelector('#list');
        var listChild = list.querySelectorAll('li');//和jQuery类似，得到的结果是一个数组
        for (var i = 0; i<listChild.length;i++){
            if(i%2 == 0){
                listChild[i].style.background = '#ccc'//listChild[i]一定要记住这种用法，！！！！！
            }
        }
   秒换算为分钟：
        var n = 1234;
        alert(parseInt(n/60) + '分' + (n%60) + '秒')
 ----------------------------------------------------------------------------------------------------------------------------------    
 2、==与！=（判断两个东西是否不相等，而！是取反）相反
 3、运算符优先级：括号。可以用括号来改变运算的优先级
 
 三、程序流程控制：
1、 switch（放的是值或者变量）{
      case 值1:
           ...
           break;
      ...
      default:
              ...
 }
 
 2、三目运算符 ？：（if...else...的简写）
 --------------------------------------------------------------------------------------------------------------------------------
         if(条件){
            语句1
        }else {
            语句2
        }
        条件？语句1：语句2
 ---------------------------------------------------------------------------------------------------------------------------------  
 3、跳出 break continue
 break：终止整个循环
 continue：终止本次循环，继续下一次循环
 
 4、什么是真，什么是假：
 真：true、非零数字、非空字符串、非空对象
 假：false、0、控制符串、null（空对象）、undefined
 
 四、json
 1、for in
 --------------------------------------------------------------------------------------------------------------------------------
        var obj = {a:2,b:3,c:5};
        for (var attr in obj){
            console.log(attr);//此处定义的变量arrt里面存的就是obj对象中的a,b,c（对象中的value）。for执行3次
            console.log(obj[attr]);//obj[attr]就是对应的每个value的key
        }       
  -------------------------------------------------------------------------------------------------------------------------------      




五、函数返回值
1、函数的返回值也就是函数的执行结果
      一个函数应该只返回一种类型的值
2、可变参：arguments （存放函数所有参数的一个数组）
---------------------------------------------------------------------------------------------------------------------------------
    当一个函数参数不定时，第一时间要想到arguments，然后利用他去控制参数arguments是一个包含所有参数的数组，arguments[i]就是具体的每个数组
          function show() {
            var result = 0;
            for (var i=0;i<arguments.length;i++){
                result += arguments[i]
            }
            console.log(result);
          }
          show(2,4,7)//13
------------------------------------------------------------------------------------------------------------------------------  
3、利用arguments来封装css（）函数
        function css(obj,attr,value) {
            if (arguments.length ==2){//获取属性
                //style只能获取设置在行内的样式，因此要获取在css中定义的样式需要用别的方式
                //获取非行间的样式使用：currentStyle（获取计算后的样式--IE）
                //在火狐下使用getComputedStyle()接受两个参数，一个是需要获取的元素，另外一个全都写false就行
                //如何让这两个写法在不同浏览器下自动切换？很简单利用true和false
//                console.log(arguments[0].currentStyle);//返回一个非空对象，利用这个可以做浏览器判断
//                if (arguments[0].currentStyle){
//                    return arguments[0].currentStyle[arguments[1]];
//                }else {
//                    return getComputedStyle(arguments[0],false)[arguments[1]];
//                }
                //获取属性很常用，为了书写方便将他封装为一个函数
                function getStyle(obj,attr) {
                    if (obj.currentStyle){
                        //currentStyle好处可以取到默认值，即使没设置属性。不过只能获取单一样式如
                        //background 结果为undefined backgroundColor结果为red
                        return obj.currentStyle[attr];
                    }else {
                        return getComputedStyle(obj,false)[attr];
                    }
                }
//                getStyle(arguments[0],arguments[1]);
                getStyle(obj,attr);
            }else {//设置属性
                //代码优化：提高代码的可读性，因为arguments和参数是可以共存的，arguments[0]===函数的第一个参数
                //所以可以给函数几个初始的参数css(obj,attr,value),相应的将arguments[i]替换掉
                //而且在函数中写3个参数不代表这一定要用到3个参数，调用的时候可以不同

//                arguments[0].style[arguments[1]] = arguments[2];
                //注意此处不能用style.arguments[1]而是要用style[arguments[1]]

                obj.style[attr] = value;
            }
        }


六、数组的使用：
1、定义：var arr1 = [1,2,3];
        var arr2 = new Array(1,2,3)
    两种方法定义数组没有任何差别    
 2、数组的属性
 length（既可以获取，也可以设置）
 数组的length可以赋值，并且赋值后会改变数组的长度，大于原数组长度后多出的部分会以空来填充，获取之后会发现是undefined
 可以利用length属性来清空数组
 3、数组的方法
         var arr1 = [1,2,3];
        var arr2 = new Array(1,2,3);
        arr1.push(4);//从尾部添加[1,2,3,4]
        arr1.unshift(5);//从头部添加[5,1,2,3]
        arr2.pop();//从尾部剔除[1,2]
        arr2.shift();//从头部剔除[2,3]
  
  4、数组排序
  arr.sort()
  sort做的工作是将数组中的任意两个值挑出来扔进sort里面进行处理
  所以进行如下改造，就可以对数字进行排序了：
        arr1.sort(function (num1,num2) {
            return num1 - num2;
        });//由小到大排序 如果是return num2 - num1;由大到小排序
   简单来说就是可以给他一个比较函数的参数，通过比较函数就可以排行顺序     
   
   5、concat（）链接两个数组
   arr1.concat(arr2);原数组不变，生成一个新数组
  
  6、join（）把数组里面的元素用分隔符拼成一个大的字符串
  arr1.join('-')//1-2-3
  
  7、split（）字符串变成数组与join相反
  var str = '1-2-3';
  str.split('-')//['1','2','3']
  
  8、数组中最靠谱最万能的splice
  所有的数组插入删除工作都可以完成
  （1）、删除数组中任意元素：splice(起始位置，需要删除的数组的长度)
  （2）、添加任意元素到数组任意位置：splice(需要添加的位置,0（此处的0代表删除0个元素，也就是从该位置开始添加所需要添加的元素）,...(此处是需要添
          加的内容，无限制，只要是在前两个参数之后都代表要添加的数组元素))
  （3）、替换数组中元素：splice(起始位置，需要删除的数组长度，需要替换的元素)   arr.splice(1,2,5,6)    
  
  
七、DOM元素操作
7.1、createElement创建节点，是在document上创建的节点：var oli = document.createElement('li');
7.2、在父元素结尾插入节点：
    var ul=;
    var li=;
    var txt=;
    var oli = document.createElement('li');
    oli.innerHTML = txt;
    ul.appendChild(oli);
 7.3、在父元素开头插入节点：
 ul.insertBefore(oli,li[0]);//有两个参数，插入的节点，和插入的位置（在谁前边插入谁）
 7.4、删除父元素里面的节点：
 ul.removeChild(oli);
 7.5、文档碎片
 document.createDocumentFragment();//文档碎片
 用于提高文档性能，原理是将创建的很多个节点打包到文档碎片里，然后在一次性渲染（相当于超市买了很多东西是一个一个往家拿还是装在袋子里一次性拿回家）
 var frag = document.createDocumentFragment();//文档碎片
    for (var i = 0;i<1000000;i++){
        var l = document.createElement('li');
        frag.appendChild(l);
    }
    ul.appendChild(frag);



八、cookie
8.1、作用：给网站保存信息，在客户端
cookie和网页缓存没有任何关系
cookie完全由js来控制
cookie有一个特性：他是完全存在客户端上的，也就是在用户的计算机上以一个文件的形式存在的
cookie只有在服务器环境下才能正常运行，（只有火狐的cookie是可以在本地运行的，其他浏览器的cookie都需要借助服务器环境才能运行）
8.2、cookie的特性
（1）、同一个网站的所有页面共享一套cookie（比如baidu.com下的页面共享的是一套cookie）
（2）、数量和大小有限（一般来讲一个网站的cookie的数量不会超过50个，大小也有限）
（3）、cookie有过期时间，一段时间之后就会消失，过期时间由js控制
8.3、在js中使用cookie
在js中，cookie实际上是document上的一个属性
alert(document.cookie);
8.3.（1）、设置cookie
          格式：名字=值 如： document.cookie = 'user=blue';
          不会覆盖：在cookie的设置中  ‘=’ 意味着添加而不是赋值 如：document.cookie = 'user=blue';        document.cookie = 'password=123';
                   得到的结果是两个
          设置过期时间：如果没有指定cookie中信息的过期时间，那么默认的是到浏览器关闭为止 。利用setDate（）方法来设置时间
                            var date = new Date();//获取当前时间
                            date.setDate(date.getDate()+30);//当前时间+30天
                            document.cookie = 'user=blue;expires='+ date;//当前时间的30天后过期
 -----------------------------------------------------------------------------------------------------------
 封装设置cookie函数：
        function setCookie(name,val,iDay) {
            var date = new Date();
            date.setDate(date.getDate()+iDay);
            document.cookie = name + '=' + val +';expires='+date
        }
 封装获取cookie函数：
         function getCookie(name) {
            var arr = document.cookie.split('; ');
            for (var i =0;i<arr.length;i++){
                var arr2 = arr[i].split('=');
                if (arr2[0] == name){
                    return arr2[1];
                }
            }
            //如果用户初次登陆还没有设置cookie此时应该返回一个''
            return '';
        }
  封装删除cookie函数：
          function removeCookie(name) {
            var date = new Date();
            date.setDate(date.getDate()-1);//原理是让该cookie在昨天就过期
            document.cookie = name + '=1;expires='+date

        }
 -------------------------------------------------------------------------------------------------------------
 
 九、AJAX
 9.1、读取的文件也必须是utf-8编码格式的
 
 
 十、面向对象：
 10.1、什么是面向对象？
 使用对象时，只关注对象提供的功能，不关注其内部细节（收音机，jQuery等）
10.2、面向对象（oop）的特点：
          一、抽象：忽略无关属性，只抓所需要的属性，可以类比函数中的参数。（登陆注册的时候人只会填写一个人所有特性中的那几项，然后传入数据库。
                    从一个真实的人到数据库的一条数据就是一个数据抽象）
          二、封装：不考虑内部实现，值考虑功能使用
          三、继承：可以改造（比如一个功能齐全的按钮，需要改变外形，继承就是拷贝过来直接改外形（不能在原码上改，会改变原来体验）。非继承就是从头开始，
          ）
 10.3、对象的组成
          由属性和方法组成
          变量和属性本质一样，区别在于从属关系不同，属性是专属于某个对象，变量一、是自由的。 函数和方法本质也一样，区别也在用从属关系，
          方法是专属于某个对象，函数则不是属于对象的。
          总结：方法就是函数，属性就是变量     
 10.4、第一个面向对象程序：
          This的定义：谁发生事件，this就是谁（当前的方法属于谁，如：
          Arr.show=function(){ alert(this)}）this是在show方法中调用的，show是属于arr的，所以this就是指的arr

          用工厂方式构造对象：
          第一步：原料（var obj =new Object();）
          第二步：加工（obj.name = name; obj.showName = function(){};）
          第三步：出厂（return obj）
          工厂方式的问题（缺点）：
          1、没有new
          2、每个对象都有一套自己的函数，这是极其浪费资源的         
10.5、this：当前方法属于谁，this就指谁（这个方法属于哪个对象的，this就指谁）。但是有一种情况例外，就是在函数前面有new 的情况下。在这种情况下，
          this指的是在构造函数内部新创建的一个对象（原料（var obj =new Object();） 指的是这里面的obj）
10.6、原型prototype
          原型的作用可以类比class 给一类元素添加方法
          Array.prototype.sum =function () {
           // .....
          }
          
          var arr = new Array();
          Array是类，不具备实际的功能（Array.push（）是错误的），只能用来构造对象。简单理解就是生产蛋糕的模子，能造出东西来，但并不能吃
                    在js中类就是构造函数，构造函数就是类
          arr是对象，是真正有功能的东西（arr.push()是正确的），是被类构造出来的
          
          用原型添加方法好处多多：可以极大简化函数。每个根据类构造出的对象都只有一套方法（所有对象共用一套方法，不用每个对象都重新创建一套方法），
          节省了资源
          
          构造函数在调用的时候前边要加new，为了区别普通函数和构造函数，应该将构造函数的首字母大写
        function CreatePerson(name,sex) {//构造函数，以他为模子，去创建新的函数
            this.name = name;
            this.sex = sex;
            //因为在使用构造函数的时候是通过new CreatePerson('blue','男');此处有new
            //可以默认的理解为new为我们做了如下处理,就是在构造函数内部自动创建了一个对象
            // 存在了变量this里面，然后在构造函数结束的时候自动return 了对象，也就是return this：
//            function CreatePerson(name,sex) {
                //var this = new Object()
//                var obj = new Object();
//                obj.name = name;
//                obj.sex =sex;
//                  ...
                //return this
//            }
//            console.log(this);//{name: "blue", sex: "男"} 因此在这的this实际是指的
            // 是这个新创建出来的对象var this = new Object()
        }
        CreatePerson.prototype.showName = function () {
            alert('我的名字是:'+this.name);
        };
        CreatePerson.prototype.showSex = function () {
            alert('我的性别是:'+this.sex);
        };
        var p1 = new CreatePerson('blue','男');
        var p2 = new CreatePerson('leo','女');

        p1.showName();
        p1.showSex();
        p2.showName();
        p2.showSex();

  其实我们是在构造函数里面添加的属性，而在原型里面添加的方法。因为每个对象的属性可能各不相同，所以我们在构造函数中添加属性，方法是所有对象都一样的
  优先级：
  给对象直接填属性比在原型上添加属性的优先级要高，依旧可以类比class（行间样式比公共样式优先级高）
  

10.7、this
      this什么时候会出问题：
      10.7.1、用到定时器的时候会出问题（但凡是被定时器调用的函数，该函数里面的this就是指的window）。
              解决方法：再套一层
                           function Aa() {
            var _this = this;//此处的this就是指的该构造函数隐式创建的一个新对象
            this.a = 12;//给新对象上的属性a赋值12
            setInterval(this.show,1000);//但凡是被定时器调用的函数，该函数里面的this就是指的window
            //解决思路是不让定时器直接调用show，在show方法外面再套一层函数,改变所属关系这样被定时器调用的函数就不是show
            setInterval(function () {//同理$('#btn).onclick = this.show()中 show（）函数里面的this指的是button按钮,解决方法：
                                       // function(){  _this.show();}
//                alert(this);//这的this依旧是window，因此要想获取Aa（）构造函数的show方法就要用_this
                _this.show();//此时调用show（）方法的对象就是Aa（）所以在show（）方法中的this就是指的
                //this.a = 12;
            },1000)
        }
        Aa.prototype.show = function () {
            alert(this.a);//但凡是被定时器调用的函数，这的this就是指的window
        };
        var obj = new Aa();




十一、实例：
11.1、调用函数什么时候加括号什么时候不加括号：加括号代表立即执行函数体内的代码，不加括号代表指向函数的指针，等onload执行完之后再去根据指针执行函数。
          例如window.onload=init;
          init函数并不会在这行代码时就执行，浏览器加载文档时这句话会被加载，会被告知文档加载完要执行哪个函数，但实际上没有当时就执行，
          等到整个文档加载完成之后才会通过init这个指针去执行init()。
11.2、charAt() 方法可返回指定位置的字符。
          var str = "HELLO WORLD";
          var n = str.charAt(str.length-1);//D          
