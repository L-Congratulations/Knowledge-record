一、变量作用域和闭包：
1、闭包的理解：子函数可以使用父函数的局部变量
          function aa() {//父函数
            var a = 12;
            function bb() {//子函数
                alert(a);//子函数可以使用父函数的局部变量
            }
            bb();
        }
二、运算符：
1、取余：%
----------------------------------------------------------------------------------------------------------------------------------
  做隔行变色：
  var list = document.querySelector('#list');
        var listChild = list.querySelectorAll('li');//和jQuery类似，得到的结果是一个数组
        for (var i = 0; i<listChild.length;i++){
            if(i%2 == 0){
                listChild[i].style.background = '#ccc'//listChild[i]一定要记住这种用法，！！！！！
            }
        }
   秒换算为分钟：
        var n = 1234;
        alert(parseInt(n/60) + '分' + (n%60) + '秒')
 ----------------------------------------------------------------------------------------------------------------------------------    
 2、==与！=（判断两个东西是否不相等，而！是取反）相反
 3、运算符优先级：括号。可以用括号来改变运算的优先级
 
 三、程序流程控制：
1、 switch（放的是值或者变量）{
      case 值1:
           ...
           break;
      ...
      default:
              ...
 }
 
 2、三目运算符 ？：（if...else...的简写）
 --------------------------------------------------------------------------------------------------------------------------------
         if(条件){
            语句1
        }else {
            语句2
        }
        条件？语句1：语句2
 ---------------------------------------------------------------------------------------------------------------------------------  
 3、跳出 break continue
 break：终止整个循环
 continue：终止本次循环，继续下一次循环
 
 4、什么是真，什么是假：
 真：true、非零数字、非空字符串、非空对象
 假：false、0、控制符串、null（空对象）、undefined
 
 四、json
 1、for in
 --------------------------------------------------------------------------------------------------------------------------------
        var obj = {a:2,b:3,c:5};
        for (var attr in obj){
            console.log(attr);//此处定义的变量arrt里面存的就是obj对象中的a,b,c（对象中的value）。for执行3次
            console.log(obj[attr]);//obj[attr]就是对应的每个value的key
        }       
  -------------------------------------------------------------------------------------------------------------------------------      




五、函数返回值
1、函数的返回值也就是函数的执行结果
      一个函数应该只返回一种类型的值
2、可变参：arguments （存放函数所有参数的一个数组）
---------------------------------------------------------------------------------------------------------------------------------
    当一个函数参数不定时，第一时间要想到arguments，然后利用他去控制参数arguments是一个包含所有参数的数组，arguments[i]就是具体的每个数组
          function show() {
            var result = 0;
            for (var i=0;i<arguments.length;i++){
                result += arguments[i]
            }
            console.log(result);
          }
          show(2,4,7)//13
------------------------------------------------------------------------------------------------------------------------------  
3、利用arguments来封装css（）函数
        function css(obj,attr,value) {
            if (arguments.length ==2){//获取属性
                //style只能获取设置在行内的样式，因此要获取在css中定义的样式需要用别的方式
                //获取非行间的样式使用：currentStyle（获取计算后的样式--IE）
                //在火狐下使用getComputedStyle()接受两个参数，一个是需要获取的元素，另外一个全都写false就行
                //如何让这两个写法在不同浏览器下自动切换？很简单利用true和false
//                console.log(arguments[0].currentStyle);//返回一个非空对象，利用这个可以做浏览器判断
//                if (arguments[0].currentStyle){
//                    return arguments[0].currentStyle[arguments[1]];
//                }else {
//                    return getComputedStyle(arguments[0],false)[arguments[1]];
//                }
                //获取属性很常用，为了书写方便将他封装为一个函数
                function getStyle(obj,attr) {
                    if (obj.currentStyle){
                        //currentStyle好处可以取到默认值，即使没设置属性。不过只能获取单一样式如
                        //background 结果为undefined backgroundColor结果为red
                        return obj.currentStyle[attr];
                    }else {
                        return getComputedStyle(obj,false)[attr];
                    }
                }
//                getStyle(arguments[0],arguments[1]);
                getStyle(obj,attr);
            }else {//设置属性
                //代码优化：提高代码的可读性，因为arguments和参数是可以共存的，arguments[0]===函数的第一个参数
                //所以可以给函数几个初始的参数css(obj,attr,value),相应的将arguments[i]替换掉
                //而且在函数中写3个参数不代表这一定要用到3个参数，调用的时候可以不同

//                arguments[0].style[arguments[1]] = arguments[2];
                //注意此处不能用style.arguments[1]而是要用style[arguments[1]]

                obj.style[attr] = value;
            }
        }


六、数组的使用：
1、定义：var arr1 = [1,2,3];
        var arr2 = new Array(1,2,3)
    两种方法定义数组没有任何差别    
 2、数组的属性
 length（既可以获取，也可以设置）
 数组的length可以赋值，并且赋值后会改变数组的长度，大于原数组长度后多出的部分会以空来填充，获取之后会发现是undefined
 可以利用length属性来清空数组
 3、数组的方法
         var arr1 = [1,2,3];
        var arr2 = new Array(1,2,3);
        arr1.push(4);//从尾部添加[1,2,3,4]
        arr1.unshift(5);//从头部添加[5,1,2,3]
        arr2.pop();//从尾部剔除[1,2]
        arr2.shift();//从头部剔除[2,3]
  
  4、数组排序
  arr.sort()
  sort做的工作是将数组中的任意两个值挑出来扔进sort里面进行处理
  所以进行如下改造，就可以对数字进行排序了：
        arr1.sort(function (num1,num2) {
            return num1 - num2;
        });//由小到大排序 如果是return num2 - num1;由大到小排序
   简单来说就是可以给他一个比较函数的参数，通过比较函数就可以排行顺序     
   
   5、concat（）链接两个数组
   arr1.concat(arr2);原数组不变，生成一个新数组
  
  6、join（）把数组里面的元素用分隔符拼成一个大的字符串
  arr1.join('-')//1-2-3
  
  7、split（）字符串变成数组与join相反
  var str = '1-2-3';
  str.split('-')//['1','2','3']
  
  8、数组中最靠谱最万能的splice
  所有的数组插入删除工作都可以完成
  （1）、删除数组中任意元素：splice(起始位置，需要删除的数组的长度)
  （2）、添加任意元素到数组任意位置：splice(需要添加的位置,0（此处的0代表删除0个元素，也就是从该位置开始添加所需要添加的元素）,...(此处是需要添
          加的内容，无限制，只要是在前两个参数之后都代表要添加的数组元素))
  （3）、替换数组中元素：splice(起始位置，需要删除的数组长度，需要替换的元素)   arr.splice(1,2,5,6)    
  
  
七、DOM元素操作
7.1、createElement创建节点，是在document上创建的节点：var oli = document.createElement('li');
7.2、在父元素结尾插入节点：
    var ul=;
    var li=;
    var txt=;
    var oli = document.createElement('li');
    oli.innerHTML = txt;
    ul.appendChild(oli);
 7.3、在父元素开头插入节点：
 ul.insertBefore(oli,li[0]);//有两个参数，插入的节点，和插入的位置（在谁前边插入谁）
 7.4、删除父元素里面的节点：
 ul.removeChild(oli);
 7.5、文档碎片
 document.createDocumentFragment();//文档碎片
 用于提高文档性能，原理是将创建的很多个节点打包到文档碎片里，然后在一次性渲染（相当于超市买了很多东西是一个一个往家拿还是装在袋子里一次性拿回家）
 var frag = document.createDocumentFragment();//文档碎片
    for (var i = 0;i<1000000;i++){
        var l = document.createElement('li');
        frag.appendChild(l);
    }
    ul.appendChild(frag);



八、cookie
8.1、作用：给网站保存信息，在客户端
cookie和网页缓存没有任何关系
cookie完全由js来控制
cookie有一个特性：他是完全存在客户端上的，也就是在用户的计算机上以一个文件的形式存在的
cookie只有在服务器环境下才能正常运行，（只有火狐的cookie是可以在本地运行的，其他浏览器的cookie都需要借助服务器环境才能运行）
8.2、cookie的特性
（1）、同一个网站的所有页面共享一套cookie（比如baidu.com下的页面共享的是一套cookie）
（2）、数量和大小有限（一般来讲一个网站的cookie的数量不会超过50个，大小也有限）
（3）、cookie有过期时间，一段时间之后就会消失，过期时间由js控制
8.3、在js中使用cookie
在js中，cookie实际上是document上的一个属性
alert(document.cookie);
8.3.（1）、设置cookie
          格式：名字=值 如： document.cookie = 'user=blue';
          不会覆盖：在cookie的设置中  ‘=’ 意味着添加而不是赋值 如：document.cookie = 'user=blue';        document.cookie = 'password=123';
                   得到的结果是两个
          设置过期时间：如果没有指定cookie中信息的过期时间，那么默认的是到浏览器关闭为止 。利用setDate（）方法来设置时间
                            var date = new Date();//获取当前时间
                            date.setDate(date.getDate()+30);//当前时间+30天
                            document.cookie = 'user=blue;expires='+ date;//当前时间的30天后过期
 -----------------------------------------------------------------------------------------------------------
 封装设置cookie函数：
        function setCookie(name,val,iDay) {
            var date = new Date();
            date.setDate(date.getDate()+iDay);
            document.cookie = name + '=' + val +';expires='+date
        }
 封装获取cookie函数：
         function getCookie(name) {
            var arr = document.cookie.split('; ');
            for (var i =0;i<arr.length;i++){
                var arr2 = arr[i].split('=');
                if (arr2[0] == name){
                    return arr2[1];
                }
            }
            //如果用户初次登陆还没有设置cookie此时应该返回一个''
            return '';
        }
  封装删除cookie函数：
          function removeCookie(name) {
            var date = new Date();
            date.setDate(date.getDate()-1);//原理是让该cookie在昨天就过期
            document.cookie = name + '=1;expires='+date

        }
 -------------------------------------------------------------------------------------------------------------
 
 九、AJAX
 9.1、读取的文件也必须是utf-8编码格式的
 
 
 十、面向对象：
 10.1、什么是面向对象？
 使用对象时，只关注对象提供的功能，不关注其内部细节（收音机，jQuery等）
10.2、面向对象（oop）的特点：
          一、抽象：忽略无关属性，只抓所需要的属性，可以类比函数中的参数。（登陆注册的时候人只会填写一个人所有特性中的那几项，然后传入数据库。
                    从一个真实的人到数据库的一条数据就是一个数据抽象）
          二、封装：不考虑内部实现，值考虑功能使用
          三、继承：可以改造（比如一个功能齐全的按钮，需要改变外形，继承就是拷贝过来直接改外形（不能在原码上改，会改变原来体验）。非继承就是从头开始，
          ）
 10.3、对象的组成
          由属性和方法组成
          变量和属性本质一样，区别在于从属关系不同，属性是专属于某个对象，变量一、是自由的。 函数和方法本质也一样，区别也在用从属关系，
          方法是专属于某个对象，函数则不是属于对象的。
          总结：方法就是函数，属性就是变量     
 10.4、第一个面向对象程序：
          This的定义：谁发生事件，this就是谁（当前的方法属于谁，如：
          Arr.show=function(){ alert(this)}）this是在show方法中调用的，show是属于arr的，所以this就是指的arr

          用工厂方式构造对象：
          第一步：原料（var obj =new Object();）
          第二步：加工（obj.name = name; obj.showName = function(){};）
          第三步：出厂（return obj）
          工厂方式的问题（缺点）：
          1、没有new
          2、每个对象都有一套自己的函数，这是极其浪费资源的         
10.5、this：当前方法属于谁，this就指谁（这个方法属于哪个对象的，this就指谁）。但是有一种情况例外，就是在函数前面有new 的情况下。在这种情况下，
          this指的是在构造函数内部新创建的一个对象（原料（var obj =new Object();） 指的是这里面的obj）
10.6、原型prototype
          原型的作用可以类比class 给一类元素添加方法
          Array.prototype.sum =function () {
           // .....
          }
          
          var arr = new Array();
          Array是类，不具备实际的功能（Array.push（）是错误的），只能用来构造对象。简单理解就是生产蛋糕的模子，能造出东西来，但并不能吃
                    在js中类就是构造函数，构造函数就是类
          arr是对象，是真正有功能的东西（arr.push()是正确的），是被类构造出来的
          
          用原型添加方法好处多多：可以极大简化函数。每个根据类构造出的对象都只有一套方法（所有对象共用一套方法，不用每个对象都重新创建一套方法），
          节省了资源
          
          构造函数在调用的时候前边要加new，为了区别普通函数和构造函数，应该将构造函数的首字母大写
        function CreatePerson(name,sex) {//构造函数，以他为模子，去创建新的函数
            this.name = name;
            this.sex = sex;
            //因为在使用构造函数的时候是通过new CreatePerson('blue','男');此处有new
            //可以默认的理解为new为我们做了如下处理,就是在构造函数内部自动创建了一个对象
            // 存在了变量this里面，然后在构造函数结束的时候自动return 了对象，也就是return this：
//            function CreatePerson(name,sex) {
                //var this = new Object()
//                var obj = new Object();
//                obj.name = name;
//                obj.sex =sex;
//                  ...
                //return this
//            }
//            console.log(this);//{name: "blue", sex: "男"} 因此在这的this实际是指的
            // 是这个新创建出来的对象var this = new Object()
        }
        CreatePerson.prototype.showName = function () {
            alert('我的名字是:'+this.name);
        };
        CreatePerson.prototype.showSex = function () {
            alert('我的性别是:'+this.sex);
        };
        var p1 = new CreatePerson('blue','男');
        var p2 = new CreatePerson('leo','女');

        p1.showName();
        p1.showSex();
        p2.showName();
        p2.showSex();

  其实我们是在构造函数里面添加的属性，而在原型里面添加的方法。因为每个对象的属性可能各不相同，所以我们在构造函数中添加属性，方法是所有对象都一样的
  优先级：
  给对象直接填属性比在原型上添加属性的优先级要高，依旧可以类比class（行间样式比公共样式优先级高）
  

10.7、this
      this什么时候会出问题：
      10.7.1、用到定时器的时候会出问题（但凡是被定时器调用的函数，该函数里面的this就是指的window）。
              解决方法：再套一层
                           function Aa() {
            var _this = this;//此处的this就是指的该构造函数隐式创建的一个新对象
            this.a = 12;//给新对象上的属性a赋值12
            setInterval(this.show,1000);//但凡是被定时器调用的函数，该函数里面的this就是指的window
            //解决思路是不让定时器直接调用show，在show方法外面再套一层函数,改变所属关系这样被定时器调用的函数就不是show
            setInterval(function () {//同理$('#btn).onclick = this.show()中 show（）函数里面的this指的是button按钮,解决方法：
                                       // function(){  _this.show();}
//                alert(this);//这的this依旧是window，因此要想获取Aa（）构造函数的show方法就要用_this
                _this.show();//此时调用show（）方法的对象就是Aa（）所以在show（）方法中的this就是指的
                //this.a = 12;
            },1000)
        }
        Aa.prototype.show = function () {
            alert(this.a);//但凡是被定时器调用的函数，这的this就是指的window
        };
        var obj = new Aa();




十一、实例：
11.1、调用函数什么时候加括号什么时候不加括号：加括号代表立即执行函数体内的代码，不加括号代表指向函数的指针，等onload执行完之后再去根据指针执行函数。
          例如window.onload=init;
          init函数并不会在这行代码时就执行，浏览器加载文档时这句话会被加载，会被告知文档加载完要执行哪个函数，但实际上没有当时就执行，
          等到整个文档加载完成之后才会通过init这个指针去执行init()。
11.2、charAt() 方法可返回指定位置的字符。
          var str = "HELLO WORLD";
          var n = str.charAt(str.length-1);//D          
