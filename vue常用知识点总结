1、v-if
        <div id="app">
            <div v-if="Math.random() > 0.5">
              Sorry
            </div>
            <div v-else>
              Not sorry
            </div>
        </div>

        <script>
        new Vue({
          el: '#app'
        })
        </script>
        ----------------------------------------------------------
        总结： 	其实v-if是判断引号""内的布尔值，布尔值为true插入，为false不插入，直接写"true"可以达到同样的效果，因为是vue封装好的
		 指令，所以""内的内容会执行而不是解释为字符串		
 		可以直接接受判断语句Math.random() > 0.5
		 
        v-show 和v-if区别：v-show 是否显示，不管满不满足条件均会在dom中，若不满足条件，则会设置成隐藏 display:none
                          v-show 不支持 <template> 语法。
                          v-if 条件判断，不满足条件的话则不会出现在dom中
                          
                          一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换 v-show 较好，
                          如果在运行时条件不大可能改变 v-if 较好。
        ----------------------------------------------------------
        
        
        
2、v-for：
v-for 指令需要以 item in items 形式的特殊语法， items 是源数据数组并且 item 是数组元素迭代的别名。

    （1）、可以遍历一个数组里面的所有内容{{site}}，{ "name": "aa" }{ "name": "bb" }{ "name": "cc" }
    也能遍历数组中每个元素的属性 {{ site.name }}，aa bb cc
                          <div id="app">
                            <ol>
                              <li v-for="site in sites">
                                {{ site.name }}
                              </li>
                            </ol>
                          </div>

                          <script>
                          new Vue({
                            el: '#app',
                            data: {
                              sites: [
                                { name: 'aa' },
                                { name: 'bb' },
                                { name: 'cc' }
                              ]
                            }
                          })
                          </script>
                          
        ---------------------------------------------
        总结：<template v-for="site in sites">
                <li>{{ site.name }}</li>
                <li>--------------</li>
              </template>
              给li套了一层模板template 而且循环的层是template 所以里面的两个li元素都会循环
        ---------------------------------------------
      （2）、也可以遍历一个对象里面的所有属性：菜鸟教程 http://www.runoob.com 学的不仅是技术，更是梦想！
      <div id="app">
        <ul>
          <li v-for="value in object">
          {{ value }}
          </li>
        </ul>
      </div>

      <script>
      new Vue({
        el: '#app',
        data: {
          object: {
            name: '菜鸟教程',
            url: 'http://www.runoob.com',
            slogan: '学的不仅是技术，更是梦想！'
          }
        }
      })
      </script>
      --------------------------------------------
       总结：<li v-for="site in sites">
                {{site}}<br/>
                ---------------
              </li>
              属性循环结果：：以li为一个循环
              菜鸟教程
              ---------------
              http://www.runoob.com
              ---------------
              学的不仅是技术，更是梦想！
              ---------------
      ----------------------------------------------
      （3）、v-for 也可以循环整数1 2 3 4 5 6 7 8 9 10
      <body>
        <div id="app">
          <ul>
            <li v-for="n in 10">
             {{ n }}
            </li>
          </ul>
        </div>

        <script>
        new Vue({
          el: '#app'
        })
        </script>
        </body>
      （4）、  你也可以提供第二个的、第三个的参数为键名：0. name : 菜鸟教程 1. url : http://www.runoob.com 
                                                      2. slogan : 学的不仅是技术，更是梦想！
      <body>
        <div id="app">
          <ul>
            <li v-for="(value, key, index) in object">
             {{ index }}. {{ key }} : {{ value }}
            </li>
          </ul>
        </div>

        <script>
        new Vue({
          el: '#app',
          data: {
            object: {
              name: '菜鸟教程',
              url: 'http://www.runoob.com',
              slogan: '学的不仅是技术，更是梦想！'
            }
          }
        })
        </script>
        </body>
3、vue计算属性
        计算属性关键词: computed。这个关键词应该是必须的，即使不是必须的也要按习惯走
        我们可以使用 methods 来替代 computed，效果上两个都是一样的，但是 computed 是基于它的依赖缓存，
        只有相关依赖发生改变时才会重新取值。而使用 methods ，在重新渲染的时候，函数总会重新调用执行。
        可以说使用 computed 性能会更好，但是如果你不希望缓存，你可以使用 methods 属性。
        计算属性在处理一些复杂逻辑时是很有用的。
        
        this指的是vue实例
        <div id="app">
                  <p>原始字符串: {{ message }}</p>
                  <p>计算后反转字符串: {{ reversedMessage }}</p>
                  <input type="text" v-model="message">
                </div>

                <script>
                var vm = new Vue({
                  el: '#app',
                  data: {
                    message: 'Runoob!'
                  },
                  computed: {
                    // 计算属性的 getter
                    reversedMessage: function () {
                      // `this` 指向 vm 实例
                      return this.message.split('').reverse().join('')//因为预期返回一个值，所以要用return
                    }
                  }
                })
                </script>
                中声明了一个计算属性 reversedMessage 。
                提供的函数将用作属性 vm.reversedMessage 的 getter 。
                vm.reversedMessage 依赖于 vm.message，在 vm.message 发生改变时，vm.reversedMessage 也会更新。
                
                
                
                computed 属性默认只有 getter ，不过在需要时你也可以提供一个 setter ：
                var vm = new Vue({
                  el: '#app',
                  data: {
                    name: 'Google',
                    url: 'http://www.google.com'
                  },
                  computed: {
                    site: {
                      // getter
                      get: function () {
                        return this.name + ' ' + this.url
                      },
                      // setter
                      set: function (newValue) {
                        var names = newValue.split(' ')
                        this.name = names[0]
                        this.url = names[names.length - 1]
                      }
                    }
                  }
                })
                // 调用 setter， vm.name 和 vm.url 也会被对应更新
                vm.site = '菜鸟教程 http://www.runoob.com';
                document.write('name: ' + vm.name);
                document.write('<br>');
                document.write('url: ' + vm.url);
                
                
                从实例运行结果看在运行 vm.site = '菜鸟教程 http://www.runoob.com'; 时，setter 会被调用，
                vm.name 和 vm.url 也会被对应更新。
                
                
                
                
                
                
                
                
4、vue样式绑定
class 与 style 是 HTML 元素的属性，用于设置元素的样式，我们可以用 v-bind 来设置样式属性。
Vue.js v-bind 在处理 class 和 style 时， 专门增强了它。表达式的结果类型除了字符串之外，还可以是对象或数组。

        （1）、我们也可以在对象中传入更多属性用来动态切换多个 class 。
        <div class="static"
             v-bind:class="{ active: isActive, 'text-danger': hasError }">
        </div>
        以上实例 div class 为：
        <div class="static active text-danger"></div>
        （2）、我们也可以直接绑定数据里的一个对象：
        
        .active {
	width: 100px;
	height: 100px;
	background: green;
        }
        .text-danger {
                background: red;
        }
        <body>
        <div id="app">
          <div v-bind:class="classObject"></div>
        </div>

        <script>
        new Vue({
          el: '#app',
          data: {
            classObject: {
              'active': true,
              'text-danger': true
            }
          }
        })
        </script>
        </body>
        
        text-danger 类背景颜色覆盖了 active 类的背景色：
        
        （3）、此外，我们也可以在这里绑定返回对象的计算属性。这是一个常用且强大的模式：
        <style>
        .active {
                width: 100px;
                height: 100px;
                background: green;
        }
        .text-danger {
                background: red;
        }
        </style>
        </head>
        <body>
        <div id="app">
          <div v-bind:class="classObject"></div>
        </div>

        <script>
        new Vue({
          el: '#app',
          data: {
          isActive: true,
          error: null
          },
          computed: {
            classObject: function () {
              return {
                active: this.isActive && !this.error,
                'text-danger': this.error && this.error.type === 'fatal',
              }
            }
          }
        })
        </script>
        </body>
        
        （4）、我们可以把一个数组传给 v-bind:class ，实例如下：
        <style>
        .active {
                width: 100px;
                height: 100px;
                background: green;
        }
        .text-danger {
                background: red;
        }
        </style>
        </head>
        <body>
        <div id="app">
                <div v-bind:class="[activeClass, errorClass]"></div>
        </div>

        <script>
        new Vue({
          el: '#app',
          data: {
            activeClass: 'active',
            errorClass: 'text-danger'
          }
        })
        </script>
        </body>
        以上实例 div class 为：<div class="active text-danger"></div>
        
        （5）、我们还可以使用三元表达式来切换列表中的 class ：
                <style>
                .text-danger {
                        width: 100px;
                        height: 100px;
                        background: red;
                }
                .active {
                        width: 100px;
                        height: 100px;
                        background: green;
                }
                </style>
                </head>
                <body>
                <div id="app">
                        <div v-bind:class="[errorClass ,isActive ? activeClass : '']"></div>
                </div>

                <script>
                new Vue({
                  el: '#app',
                  data: {
                    isActive: true,
                        activeClass: 'active',
                    errorClass: 'text-danger'
                  }
                })
                </script>
                </body>
                errorClass 是始终存在的，isActive 为 true 时添加 activeClass 类：
	 ---------------------------------------------------------------------------------
	 总结：v-bind:class=""为了结构清晰，方便管理，采用传入对象的方式；
	 v-bind：class=""的作用是根据条件不同来决定添加哪个类，可以直接对象进行添加：	
	 classObject: {
		      'active': true,
		      'text-danger': true
		    }
	 也可以绑定返回对象的计算属性：
	 computed: {
            classObject: function () {
              return {
                active: this.isActive && !this.error,
                'text-danger': this.error && this.error.type === 'fatal',
              }
            }
          }
	 
	 
	 
          <div v-bind:class="classObject"></div>        
		<script>
		new Vue({
		  el: '#app',
		  data: {
		    classObject: {
		      'active': true,
		      'text-danger': true
		    }
		  }
		})
		</script>
       
	 ---------------------------------------------------------------------------------
 （6）、我们可以在 v-bind:style 直接设置样式：（可以这样写 但为了结构清晰应该采用下面那种方式）
		 <body>
		<div id="app">
			<div v-bind:style="{ color: activeColor, fontSize: fontSize + 'px' }">菜鸟教程</div>
		</div>

		<script>
		new Vue({
		  el: '#app',
		  data: {
		    activeColor: 'green',
			fontSize: 30
		  }
		})
		</script>
		</body>
	以上实例 div style 为：<div style="color: green; font-size: 30px;">菜鸟教程</div>
	 （7）、也可以直接绑定到一个样式对象，让模板更清晰：采用这种方式
 	<body>
	<div id="app">
	  <div v-bind:style="styleObject">菜鸟教程</div>
	</div>

	<script>
	new Vue({
	  el: '#app',
	  data: {
	    styleObject: {
	      color: 'green',
	      fontSize: '30px'
	    }
	  }
	})
	</script>
	</body>
	（8）、v-bind:style 可以使用数组将多个样式对象应用到一个元素上：
	<body>
	<div id="app">
	  <div v-bind:style="[baseStyles, overridingStyles]">菜鸟教程</div>
	</div>

	<script>
	new Vue({
	  el: '#app',
	  data: {
	    baseStyles: {
	      color: 'green',
	      fontSize: '30px'
	    },
		overridingStyles: {
	      'font-weight': 'bold'
	    }
	  }
	})
	</script>
	</body>
	注意：当 v-bind:style 使用需要特定前缀的 CSS 属性时，如 transform ，Vue.js 会自动侦测并添加相应的前缀。
	 -------------------------------------------
	 总结：
	 接受数组对象： <div v-bind:style="[baseStyles, overridingStyles]">菜鸟教程</div>
	  data: {
	    baseStyles: {
	      color: 'green',
	      fontSize: '30px'
	    },
		overridingStyles: {
	      'font-weight': 'bold'
	    }
	  }
	  -	
	------------------------------------------------------------------------------------  
	  
	  
	  
	  
	  
	  
	  
	  
Vue.js 事件处理器
 v-bind只能绑定属性不能绑定事件？
 （1）、事件监听可以使用 v-on 指令：
	 <div id="app">
	  <button v-on:click="counter += 1">增加 1</button>//在vue中所有""中的变量都是从vue实例中取得值，然后进行逻辑计算	
	  <p>这个按钮被点击了 {{ counter }} 次。</p>
	  
	   在v-on:click="counter += 1"中counter双向绑定所以值进行了+1	
  
	</div>

	<script>
	new Vue({
	  el: '#app',
	  data: {
	    counter: 0
	  }
	})
	</script

	通常情况下，我们需要使用一个方法来调用 JavaScript 方法。
	v-on 可以接收一个定义的方法来调用。
	<body>
	<div id="app">
	   <!-- `greet` 是在下面定义的方法名 -->
	  <button v-on:click="greet">Greet</button>
	</div>

	<script>
	var app = new Vue({
	  el: '#app',
	  data: {
	    name: 'Vue.js'
	  },
	  // 在 `methods` 对象中定义方法
	  methods: {
	    greet: function (event) {
	      // `this` 在方法里指当前 Vue 实例
	      alert('Hello ' + this.name + '!')
	      // `event` 是原生 DOM 事件
		  if (event) {
			  alert(event.target.tagName)
		  }
	    }
	  }
	})
	// 也可以用 JavaScript 直接调用方法
	app.greet() // -> 'Hello Vue.js!'
	</script>
	</body>
	 ---------------------------------------------------------------
	 总结：定义方法要在methods对象中定义，
	 在vue实例中定义的函数在实例外也可以直接调用app.greet() // -> 'Hello Vue.js!'	
 	-----------------------------------------------------------------------------------
	
	
 	除了直接绑定到一个方法，也可以用内联 JavaScript 语句：
	<div id="app">
	  <button v-on:click="say('hi')">Say hi</button>
	  <button v-on:click="say('what')">Say what</button>
	</div>

	<script>
	new Vue({
	  el: '#app',
	  methods: {
	    say: function (message) {
	      alert(message)
	    }
	  }
	})
	</script>
	 （2）、事件修饰符
		Vue.js 为 v-on 提供了事件修饰符来处理 DOM 事件细节，如：event.preventDefault() 或 event.stopPropagation()。
		Vue.js通过由点(.)表示的指令后缀来调用修饰符。
		.stop
		.prevent
		.capture
		.self
		.once
		<!-- 阻止单击事件冒泡 -->
		<a v-on:click.stop="doThis"></a>
		<!-- 提交事件不再重载页面 -->
		<form v-on:submit.prevent="onSubmit"></form>
		<!-- 修饰符可以串联  -->
		<a v-on:click.stop.prevent="doThat"></a>
		<!-- 只有修饰符 -->
		<form v-on:submit.prevent></form>
		<!-- 添加事件侦听器时使用事件捕获模式 -->
		<div v-on:click.capture="doThis">...</div>
		<!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 -->
		<div v-on:click.self="doThat">...</div>

		<!-- click 事件至少触发一次，2.1.4版本新增 -->
		<a v-on:click.once="doThis"></a>
	 （3）、按键修饰符
		Vue 允许为 v-on 在监听键盘事件时添加按键修饰符：
		<!-- 只有在 keyCode 是 13 时调用 vm.submit() -->
		<input v-on:keyup.13="submit">
		记住所有的 keyCode 比较困难，所以 Vue 为最常用的按键提供了别名：
		<!-- 同上 -->
		<input v-on:keyup.enter="submit">
		<!-- 缩写语法 -->
		<input @keyup.enter="submit">
		全部的按键别名：
		.enter
		.tab
		.delete (捕获 "删除" 和 "退格" 键)
		.esc
		.space
		.up
		.down
		.left
		.right
		.ctrl
		.alt
		.shift
		.meta
		实例
		
		
		
		<p><!-- Alt + C -->//                                  alt+c		
		<input @keyup.alt.67="clear">
		<!-- Ctrl + Click -->
		<div @click.ctrl="doSomething">Do something</div>	
		
		--------------------------------------------
		 总结：事件绑定只能用v-on ：后面加触发事件 =""里面加具体函数
		 触发事件可以用修饰符进行更详细的控制用.来调用修饰符
		 触发事件可以用按键组合来丰富
		 -----------------------------------------------
