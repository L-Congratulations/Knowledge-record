vue开发移动端：
http://www.jb51.net/article/96400.htm
------------------------------------------------------------------------------------------------------------------------
vue打包：
http://www.jianshu.com/p/e952fa42880e  Cordova打包教程（H5项目打包成ipa）
http://www.jianshu.com/p/25d797b983cd   Cordova打包Vue项目Android
http://www.cnblogs.com/wujindong/p/5647101.html
http://www.51xuediannao.com/jiqiao/cordova_android_release.html
http://blog.csdn.net/settingsun66/article/details/53581237
C:\Users\ls-pc\AppData\Local\Android\sdk\platforms
百度下载安装sdk。
cordova@6.0.0
http://cordova.apache.org/docs/en/latest/reference/cordova-cli/index.html#syntax // cordova官网
1.jdk.1.8

2.安装android sdk：直接安装android studio，配置环境变量的路径从那里面去找

3.安装ant：官网下载http://ant.apache.org。然后解压。并配置环境变量：
ANT_HOME    C:/ apache-ant-1.8.1

path             C:/ apache-ant-1.8.1/bin

classpath      C:/apache-ant-1.8.1/lib
检测安装是否成功：输入如下命令：ant

如果出现如下内容，说明安装成功：

Buildfile: build.xml does not exist!

Build failed
------------------------------------------------------------------------------------------------------------------------
vue缓存：

------------------------------------------------------------------------------------------------------------------------
vue按需加载：
//懒加载路由  
const routes = [  
  {          //当首次进入页面时，页面没有显示任何组件；让页面一加载进来就默认显示first页面  
    path:'/',   //重定向，就是给它重新指定一个方向，加载一个组件；  
    component:resolve => require(['@/components/First'],resolve)  
  },  
  {  
    path:'/first',  
    component:resolve => require(['@/components/First'],resolve)  
  },  
  {  
    path:'/second',  
    component: resolve => require(['@/components/Second'],resolve)  
  }  
//这里require组件路径根据自己的配置引入  
]  
------------------------------------------------------------------------------------------------------------------------
vue权限控制：
http://www.cnblogs.com/yeziTesting/p/7189731.html
https://juejin.im/post/59097cd7a22b9d0065fb61d2
------------------------------------------------------------------------------------------------------------------------
axios高并发处理：
function getUserAccount(){
  return axios.get('/user/12345');
}
function getUserPermissions(){
  return axios.get('/user/12345/permissions');
}
axios.all([getUserAccount(),getUserPermissions()])
  .then(axios.spread(function(acct,perms){
    //当这两个请求都完成的时候会触发这个函数，两个参数分别代表返回的结果
  }))
  
  //iterable是一个可以迭代的参数如数组等
axios.all(iterable)
//callback要等到所有请求都完成才会执行
axios.spread(callback)
详细教程：
http://www.jianshu.com/p/df464b26ae58
----------------------------------------------------------------------------------------------------------------------

大家都知道国内直接使用 npm 的官方镜像是非常慢的，这里推荐使用淘宝 NPM 镜像。
npm install -g cnpm --registry=https://registry.npm.taobao.org
这样就可以使用 cnpm 命令来安装模块了：
cnpm install [name]
安装webpack
cnpm install webpack -g
安装vue脚手架
npm install vue-cli -g 

 要创建项目，首先我们要选定目录，然后再命令行中把目录转到选定的目录。在这里，我选择桌面来存放新建的项目，则我们需要先把目录cd到桌面，
  如下图。在桌面目录下，在命令行中运行命令 vue init webpack firstVue 。解释一下这个命令，这个命令的意思是初始化一个项目，其中
  webpack是构建工具，也就是整个项目是基于webpack的。其中firstVue是整个项目文件夹的名称，这个文件夹会自动生成在你指定的目录中
  （会有一些初始化的设置，如下输入:
  Target directory exists. Continue? (Y/n)直接回车默认(然后会下载 vue2.0模板，这里可能需要连代理)
  Project name (vue-test)直接回车默认
  Project description (A Vue.js project) 直接回车默认
  Author 写你自己的名字
  
   在项目目录中，运行命令 npm run dev ，会用热加载的方式运行我们的应用，热加载可以让我们在修改完代码后不用手动刷新浏览器就能实时
  看到修改后的效果。
  这里简单介绍下 npm run dev 命令，其中的“run”对应的是package.json文件中，scripts字段中的dev，也就是 node build/dev-server.js命
  令的一个快捷方式。
  
  
  v-for还能循环组件：
  <componnentA v-for="(value, key) in objectList" :key='key'></componnentA>
  
  vue中的某些方法是可以直接触发视图更新的如push()等，但是有的方法不能触发视图更新。如果想实现的话可以调用vue的全局方法set方法：
  methods:{
      add(){
        Vue.set(this.ObjectList,1,{ // 第一个参数是要改变的数组，第二个参数是改变的数组的位置，第三个参数是将要改变的内容
            name:'bbb'
          })
      }
  }
  
  $emit方法定义自定义事件。
  -------------------------------------------------------------------------------------------------------------------------
  vue表单：v-model来绑定表单
  多选：
  <input type="checkbox" v-model="check" value="apple1">
    <input type="checkbox" v-model="check" value="apple2">
    <input type="checkbox" v-model="check" value="apple3">
    <input type="checkbox" v-model="check" value="apple4">
    {{check}}
  要在vue实例中声明check是一个数组：
   data: {
            check:[]
        },
  v-model支持三种修改器：
  v-model.lazy="myvalue" // 用于在input框内内容完成时更新视图，而不是每次输入一个字母都更新
  v-model.number // 将value值转为number类型，如果不加则默认是字符串
  v-model.trim  // 去除视图和双向绑定的数据中的前后空格
  ---------------------------------------------------------------------------------------------------------------------
  computed计算属性：可以根据其他属性（数据）来动态的更新计算属性。在一些场景下可以不使用事件监听而直接使用计算属性进行替代。
  和method区别，就是无论所依赖的数据是否改变method的方法都会在调用的时候重新获取计算。计算属性则只有在依赖的数据发生变化的时候才重新计算。
  用双大括号调用method方法时要加（），而计算属性在调用的时候直接传入函数名就行
  用法一：当过滤器用：
  <input type="text" v-model.trim="check" value="apple1">
    {{myvalue}}
    computed:{
            myvalue(){
                return this.check.replace(/\d/g,'')  // 在这可以对数据进行任何形式的加工
            }
        }
  -----------------------------------------------------------------------------------------------------------------------------
  属性监听：监听一个vue的变量，每当变量改动的时候都进行相应的操作。使用vue实例的watch参数选项。
  watch:{
            check:function(value,oldvalue){  // check是需要监听的对象，后面跟的是一个函数，里面包含俩参数，新值和旧值

            }
        }
 ---------------------------------------------------------------------------------------------------------------------------
 vue大小写不敏感
 ---------------------------------------------------------------------------------------------------------------------------
 组件：
 父组件中引入子组件需要先引入，然后在父组件实例的components里面注册：
 import App from './App'
 components: { App }
 除了直接标签引入子组件也可以使用属性绑定的:is引入组件。好处是动态渲染组件，可以根据不同需求在同一位置渲染不同的组件 :is='TocomA' 然后在
 data里面声明return{TocomA:'comA'} // comA是用import引入的子组件
 组件间通信：
 父组件通过子组件标签进行数据传递：<childcomponent  num = 4></childcomponent>，子组件通过props接受数据:props:['number']，
 用props接收到的数据和data中声明的一样,所以也没有必要再去data里面声明一遍。在vue中属性大小写不敏感，尽量不要使用驼峰方式。
 在props中使用驼峰方式命名的属性在html结构中需要使用-加小写字母的方式进行转化。
 props也可以接收对象
 
 <input type="text" v-model="myval">
  <com-a :myvalue="myval"></com-a> // 这里要用属性绑定:myvalue才能将myval变量正确赋值，否则只是一个字符串。在这:myvalue中的myvalue是子组件中的
  属性名。
  
  子组件向父组件传递数据：
  通过事件触发。
  在子组件中定义一个传递数据的事件：<button @click="emit"></button>
  然后在methods中定义emit方法：
  emit(){
      this.emit('myevent',this.hello) // myevent是自定义事件，用来
      // 进行事件传递的，this.hello就是需要传的参数
    }
    
    在父组件中，通过标签作为桥梁：
    <com-a :myval="myval" @myevent="getchild"></com-a>  使用事件绑定 @myevent将子组件的事件获取到 myevent是在子组件中emit方法中定义的
    自定义事件，当自定义事件被触发的时候调用getchild方法。在调用getchild的时候传入的参数就是在子组件中想要传入的数据：
    getchild(hello){
        console.log(hello)
    }
    
    插槽slot
    
    动态组件：就是用属性绑定的:is通过给他的值付不同的值来更换该位置需要渲染的组件：
    <p :is="changecomment"></p>
    changecomment:'coma'
    当事件触发的时候通过改变changecomment的值来添加需要显示的组件。和路由相似，也支持<keep-alive></keep-alive>
    
 ---------------------------------------------------------------------------------------------------------------------------
 vue-router:

 在router文件夹的index.js的router实例中添加参数选项：
 export default new Router({
  mode:'history',
  routes: [
    {
      path: '/',
      name: 'Hello',
      component: Hello
    }
  ]
})
就可以去除掉路由中的哈希值#
用routerlingk进行页面内跳转：
 <router-link :to="{path:'apple'}"></router-link>
 
 路由传参：
 path: '/apple/:color',
 使用this.$route.params 获取到路由参数
 {{$$route.params.color}}
 ---------------------------------------------------------------------------------------------------------------------------
 vue的状态管理：vuex
 在完整项目中有时候组件会共享一个状态，比如用户的登陆状态。比如一个购物车在多个地方使用。当我改变头部的购物车信息的时候其他地方的购物车也
 需要同时更新状态
 
 ---------------------------------------------------------------------------------------------------------------------------
 
 
vue的三个功能：模板渲染、模块化、扩展功能（路由，ajax）

组件：
在vue实例中有一个参数选项components
 let vm = new Vue({
        el:'#demo',
        data:{

        },
        components:{
            'my-header': myHeader // my-header是标签 myHeader是模板，而且myHeader本身也是一个vue的实例对象，所以可以像定义vue实例一样去定义
            // myHeader里面的参数选项。

        }
    })
let myHeader = {
    template:'<p>{{myheader}} <my-header-child></my-header-child></p>',
    data:function () { // 注意在组件中data是函数
        return{
            myheader:'this is header'
        }
    },
    components:{
        'my-header-child': myHeaderChild

    }
};



核心就是充分利用数据绑定，充分利用数组，使用vue提供的方法将效果实现出来。
数据驱动：获取数据通过vue指令来获取，而不是通过dom的value属性来获取。数据驱动精髓，就是通过定义vue数据来控制，而不是获取dom属性。一切都是以操作
数据为目的，通过改变数据来让vue自动映射到视图
通过双向数据绑定将dom中元素的值获取到，而不是通过dom的value属性来获取。
简单的理解就是能用vue实现的就不用JavaScript实现
拿到数据的方法：双向数据绑定，再循环中传参
如果vue提供的方法不能满足要求，仍需要使用JavaScript操作dom，那么可以使用自定义指令directives（），来封装JavaScript的方法，来满足要求
directives（
"focus":{
 update(el,binding) // updata会监控数据变化，当数据改变时触发focus函数
}
）
计算属性：computed
一、mdn
1.1、css在app端兼容性问题基本为0
1.2、跨域：协议、域名、端口、不同都为跨域。
其中一种方式是在服务器端配置一下header（“Access-control。。。。”），在客户端不需要做任何事情。就可以去请求已配置了header参数的服务器资源

二、查找vue的库，可以从vue的GitHub上点击vue标签就能找到

三、vue是一个渐进式框架：可以根据需求自定义的进行扩展。不用把一整套东西全都用上（只渲染视图-》整个应用）
3.1、vue的两个核心点：响应的数据绑定和组合的视图模型
3.1.1、响应的数据绑定：
所谓的数据驱动就是当数据发生变化的时候，用户界面发生相应的变化，开发者不需要手动的去修改dom。
 Object.defineProperty
 
 3.1.2、组合的视图模型：
 
 3.2、虚拟dom：
 vue的模板（咱们写的代码）--》vue调用createElement渲染函数将vue模板进行解析--》通过render方法返回的结果就是虚拟dom树（一个包含模板所有属性的对象）
 --》 虚拟dom树经过调用方法生成真正的dom节点。   当数据发生改变的时候新旧虚拟dom树会进行对比，然后只渲染改动的地方
 
 3.2、mvvm
 m：数据模型  数据通过视图进行展示
 v：视图模板
 vm：视图模型  拿到数据之后通过vm将数据与视图进行绑定   当用户交互的时候通过vm监听事件与数据进行交互 视图和数据通过vm进行联系
 在vue中 new Vue（） 就是vm层
 
 四、模板
 4.1、html模板。就是正常写的html
 4.2、字符串模板：vue实例中的template。将一段字符串翻译成html代码。根节点只能有一个（如不能在字符串的最外层元素包含多个同级div）
 灵活的用法：将字符串放在一个类型为x-template的script标签内，在vue实例template属性上通过ID将字符串进行转义为html。放在哪？？？
 4.3、render函数：
 在vue实例中有一个render函数，有一个默认的参数createElement方法，在这个方法上进行
render:function(createElement) {
            return createElement(
                'ul',
                {},  // 属性写在对象里面，子元素写在数组里面，逐层嵌套
                [
                    createElement('li',1)
                ]

            )
        }
 
 掌握一门框架：
 1、核心理念
 2、基本语法
 3、常用方法（数据传递，路由，http服务等）



五、指令：

5.1、v-for
首先循环的是数组中的每一项：item in items    item=items[i],至于items[i]是一个数组还是一个对象看具体数据
如果直接是循环一个对象，而不是数组，那么直接使用
v-for 指令需要以 item in items 形式的特殊语法， items 是源数据数组并且 item 是数组元素迭代的别名。
    （1）、可以遍历一个数组里面的所有内容{{site}}，{ "name": "aa" }{ "name": "bb" }{ "name": "cc" }
    也能遍历数组中每个元素的属性 {{ site.name }}，aa bb cc
                          <div id="app">
                            <ol>
                              <li v-for="site in sites">
                                {{ site.name }}
                              </li>
                            </ol>
                          </div>

                          <script>
                          new Vue({
                            el: '#app',
                            data: {
                              sites: [
                                { name: 'aa' },
                                { name: 'bb' },
                                { name: 'cc' }
                              ]
                            }
                          })
                          </script>
                          
        ---------------------------------------------
        总结：<template v-for="site in sites">
                <li>{{ site.name }}</li>
                <li>--------------</li>
              </template>
              给li套了一层模板template 而且循环的层是template 所以里面的两个li元素都会循环
        ---------------------------------------------
      （2）、也可以遍历一个对象里面的所有属性：菜鸟教程 http://www.runoob.com 学的不仅是技术，更是梦想！
      <div id="app">
        <ul>
          <li v-for="value in object">
          {{ value }}
          </li>
        </ul>
      </div>

      <script>
      new Vue({
        el: '#app',
        data: {
          object: {
            name: '菜鸟教程',
            url: 'http://www.runoob.com',
            slogan: '学的不仅是技术，更是梦想！'
          }
        }
      })
      </script>
      --------------------------------------------
       总结：<li v-for="site in sites">
                {{site}}<br/>
                ---------------
              </li>
              属性循环结果：：以li为一个循环
              菜鸟教程
              ---------------
              http://www.runoob.com
              ---------------
              学的不仅是技术，更是梦想！
              ---------------
      ----------------------------------------------
      （3）、v-for 也可以循环整数1 2 3 4 5 6 7 8 9 10
      <body>
        <div id="app">
          <ul>
            <li v-for="n in 10">
             {{ n }}
            </li>
          </ul>
        </div>

        <script>
        new Vue({
          el: '#app'
        })
        </script>
        </body>
      （4）、  你也可以提供第二个的、第三个的参数为键名：0. name : 菜鸟教程 1. url : http://www.runoob.com 
                                                      2. slogan : 学的不仅是技术，更是梦想！
      <body>
        <div id="app">
          <ul>
            <li v-for="(value, key, index) in object">
             {{ index }}. {{ key }} : {{ value }}
            </li>
          </ul>
        </div>

        <script>
        new Vue({
          el: '#app',
          data: {
            object: {
              name: '菜鸟教程',
              url: 'http://www.runoob.com',
              slogan: '学的不仅是技术，更是梦想！'
            }
          }
        })
        </script>
        </body>
5.2、v-on：
<input v-module="todo">

data{
todo:"",
}
methods:{
            add(){
                this.list.push({
                    title:this.todo //通过双向数据绑定来获取值，
                });
                this.todo = '' // 事件完成之后制空input框
            }
        }

