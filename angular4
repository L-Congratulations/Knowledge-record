一、angular4程序架构:
1.1、user<-->angular App <--> server
用户与angular App进行交互，然后angular App 与server进行交互
每个App至少要包含一个模块 NgModule（app就是由模块构成的），每个模块中有若干组件Component构成（模块就是由组件构成）component
1.1.1、组件
是angular应用的基本构建块，组件直接有父子关系。
组件可以调用服务
服务：是用来封装可重用的业务逻辑。比如获取商品信息的逻辑。在不同的组件间进行调用。服务之间也可以互相调用
指令：指令也是重要组成部分，指令允许你向html元素添加自定义行为
模块：用来将应用中不同的部分组成angular框架可以理解的单元

组件、服务、指令是用来完成功能的。
模块是用来打包分发功能的

1.2、ng-cli创建的目录分析
e2e：端到端测试，用来做自动化测试的
src：应用的源代码目录
angular-cli.json:angular命令行工具的配置文件，实战中会去修改这个文件，比如引入第三方的包的时候
package.json：npm命令工具配置文件
tslint.json：tslint的配置文件，做代码规则检测的 
src/environments：环境配置，可以在不同的环境（开发环境、生产环境、测试环境）开发。比如开发环境和生产环境的后台地址是不一样的
就需要在这里进行配置
src/polyfills.ts:使angular能够正常的运行在老的浏览器 
src/tsconfig.json:是typescript编译器的配置文件，已经配好，基本不用修改

1.3、关键文件的代码分析

1.3.1、组件：app.component.ts
与组件相关的基本概念：
（1）@Component（）装饰器
用来告知angular框架如何处理一个typescript的类。component包含多个属性，这些属性
的值叫做元数据。angular会根据这些元数据的值来渲染组件并执行组件的逻辑
（2）Template 模板
我们可以在模板中使用angular的数据绑定语法，来呈现控制器中的数据
（3）Controller控制器
就是一个普通的typescript类，他会被Component装饰器来装饰。控制器会包含组件所有的
属性和方法，绝大多数页面逻辑都是写在控制器里的。控制器通过数据绑定与模板（template）
进行通信，模板（template）展示控制器（Controller）的数据。控制器处理模板
（template）上发生的事件。
以上三点是组件的必备元素。
import { Component } from '@angular/core';
// 从angular的核心模块中引入了component装饰器

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
// 用装饰器定义了一个组件 以及组件的元数据
// 所有组件都必须使用一个component装饰器来注解
// （前边带有@的是装饰器）

export class AppComponent {
  // AppComponent是一个标准的typescript类
  // 要告诉angular AppComponent是一个组件需要把
  // 一些元数据附加到这个类上。在typescript中我们使用装饰器来附加元数据
  // 通过@Component把一些元数据加到 AppComponent类上
  // angular就会知道需要把AppComponent变成angular框架
  // 的一个组件
  // 元数据会告诉angular如何将AppComponent处理成一个组件

  // AppComponent这个typescript类定义了这个组件的控制器
  // 数据绑定是让模板的各个部分与控制器的各个部分相互作用的一个机制
  
  title = 'app';
}
（4）、非必备要素：
可选的可注入对象：属性输入@Inputs（）、提供器providers（用来做依赖注入的）、声明周期钩子
可选的输出对象：生命周期钩子、样式表、动画、输出属性@Outputs（）

1.3.2、模块app.module.ts
模块也是由装饰器修饰的typescript类

import { BrowserModule } from '@angular/platform-browser';

import { NgModule } from '@angular/core';

import { AppComponent } from './app.component';

@NgModule({
  declarations: [
    // declarations声明了模块中有什么东西，在这只声明
    // 了一个组件AppComponent。
    // 注意在这个属性中只能声明组件、指令和管道
    AppComponent
  ],
  imports: [
    // 声明了模块要正常运转还需要什么东西。也就是AppModule
    // 模块需要依赖的其他模块。在这声明了一个angular框架
    // 提供的模块BrowserModule（是开发web应用的必选依赖）
    // 还有FormsModule（处理表单的模块）、HttpModule等
    // （提供http服务的模块）等肯能用到的模块
    // 当把模块引入之后就可以在应用中使用这些模块所提供的
    // 组件、指令、服务等
    BrowserModule
  ],
  providers: [],
  // providers默认是空的。用来声明模块中提供了什么服务
  // 依赖注入的时候使用。这里只能声明服务。服务只能声明在
  // 这里
  bootstrap: [AppComponent]
  // bootstrap声明了模块的主组件是什么
})
export class AppModule { }

1.4、angular启动过程
启动的配置在angular-cli.json文件中
src/main.ts是整个应用启动的入口，整个应用的起点是从
platformBrowserDynamic().bootstrapModule(AppModule);开始运行的，
加载AppModule模块，首先分析app.module.ts(是AppModule对应的那个主模块)
需要依赖哪些模块（比如BrowserModule模块），把依赖的那些模块加载了之后再
分析那些模块需要什么模块，直到加载完所有所需的依赖。加载完之后会去index.html
中寻找<app-root></app-root>标签并把app.component.ts中装饰器中templateUrl
所指定的'./app.component.html'内容替换掉app-root标签。在替换的过程中主页面
会显示<app-root>Loading。。。</app-root>中的内容（loading。。。）

二、auction第一个版本
2.1、设置依赖
在项目中会用到jQuery和bootstrap等第三方的库，所以在开发前需要把库引入到我们的项目中：
（1）、将第三方库安装到本地
在auction项目目录下：npm install jquery --save(--save是为了吧jQuery记入到package.json文件中)
npm install bootstrap --save
（2）、把库引入到项目中
需要修改angular-cli.json文件。在文件中添加：
"styles": [
        "styles.css",
        "../node_modules/bootstrap/dist/css/bootstrap.css"
      ],
"scripts": [
  "../node_modules/jquery/dist/jquery.js",
  "../node_modules/bootstrap/dist/js/bootstrap.js"
],

（3）、因为jQuery是JavaScript的东西，typescript是不能直接使用的。需要安装jQuery和bootstrap的类型描述文件才能在typescript中正常使用
npm install @types/jquery --save-dev（不加dev放在package.json 的dependencies里面 ,加dev放在package.json的 devDependencies里面）
npm install @types/bootstrap --save-dev
安装完成。

2.2、angular开发思路：
在angular框架设计目标中最主要的目标之一就是方便开发人员开发出可重用的组件。很多特性都是为这个服务的。
开发的时候要用一种组件化的思路来思考我们要解决的问题。
将auction应用模块分成七个组件进行开发：navbar、footer、search、carousel、product、stars

2.2.1、es6 class类知识点补充
//定义类
class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  toString() {
    return '(' + this.x + ', ' + this.y + ')';
  }
}
上面代码定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象
Point类除了构造方法，还定义了一个toString方法。注意，定义“类”的方法的时候，前面不需要加上function这个关键字，
直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。
constructor方法是类的默认方法
constructor方法默认返回实例对象（即this）
与 ES5 一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。
//定义类
class Point {

  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  toString() {
    return '(' + this.x + ', ' + this.y + ')';
  }

}

var point = new Point(2, 3);

point.toString() // (2, 3)

point.hasOwnProperty('x') // true
point.hasOwnProperty('y') // true
point.hasOwnProperty('toString') // false
point.__proto__.hasOwnProperty('toString') // true
上面代码中，x和y都是实例对象point自身的属性（因为定义在this变量上），所以hasOwnProperty方法返回true，
而toString是原型对象的属性（因为定义在Point类上），所以hasOwnProperty方法返回false。这些都与 ES5 的行为保持一致。

与 ES5 一样，类的所有实例共享一个原型对象。

var p1 = new Point(2,3);
var p2 = new Point(3,2);

p1.__proto__ === p2.__proto__
//true
上面代码中，p1和p2都是Point的实例，它们的原型都是Point.prototype，所以__proto__属性是相等的。

这也意味着，可以通过实例的__proto__属性为“类”添加方法。

__proto__ 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的JS引擎中都提供了这个私有属性
，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 Object.getPrototypeOf 方法来获取实例对象的原型，
然后再来为原型添加方法/属性。

var p1 = new Point(2,3);
var p2 = new Point(3,2);

p1.__proto__.printName = function () { return 'Oops' };

p1.printName() // "Oops"
p2.printName() // "Oops"

var p3 = new Point(4,2);
p3.printName() // "Oops"
上面代码在p1的原型上添加了一个printName方法，由于p1的原型就是p2的原型，因此p2也可以调用这个方法。
而且，此后新建的实例p3也可以调用这个方法。这意味着，使用实例的__proto__属性改写原型，必须相当谨慎，
不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。
--------------------------------------------------------------------------------------------------------------------------------
总结：在es6 的class类中
class Point {

  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  toString() {
    return '(' + this.x + ', ' + this.y + ')';
  }

}

var point = new Point(2, 3);

point.toString() // (2, 3)

point.hasOwnProperty('x') // true
point.hasOwnProperty('y') // true
point.hasOwnProperty('toString') // false
point.__proto__.hasOwnProperty('toString') // true
在constructor里面定义的x和y都是(class类自身的属性)实例对象point自身的属性（因为定义在this变量上），所以hasOwnProperty方法返回true，
在constructor外面定义的toString是class类原型对象的属性（因为定义在Point类上），所以hasOwnProperty方法返回false。
类的所有实例共享一个原型对象。
区分：一个是类自己的，一个是类原型上的。
-----------------------------------------------------------------------------------------------------------------------------

2.2.2、typescript中的类
extends 继承时的父类
private 装载私有属性，里面定义的成员外部不可使用且不能继承给子类，当成员被标记成private时，它就不能在声明它的类的外部访问。
protected 装载保护属性，里面定义的成员外部不可使用但可以继承给子类
public 装载公有属性默认为public
static 装载静态方法和属性
class Animal {
    private name: string;
    constructor(theName: string) { this.name = theName; }
}

new Animal("Cat").name; // Error: 'name' is private;


2.3、在typescript中创建产品数据
首先在typescript中定义一个对象来封装产品信息，并做格式限制。
然后在组件的controller中定义一个数组用来存储需要展现的产品信息
最后在ngOnInit生命周期钩子中初始化数组。
完整代码如下：
export class ProductComponent implements OnInit {
  private products: Array<Product>;
  // 在定义完产品信息之后我们需要在ProductComponent
//   控制器中去声明一个数组，来存储页面上将要
//   展示的产品的数据
//  该数组是一个受Product格式限制的数组
  constructor() { }

  ngOnInit() {
    // ngOnInit声明周期钩子，会在组件实例化
    // 之后调用一次
    this.products = [
      new Product(1, '第一个商品', 1.88, 3.5, 'angular4.0', ['图书', '硬件设备']),
      new Product(2, '第二个商品', 2.88, 2.5, 'angular4.0', ['电子产品', '硬件设备']),
      new Product(3, '第三个商品', 3.88, 4.5, 'angular4.0', ['硬件设备']),
      new Product(4, '第四个商品', 4.88, 2.5, 'angular4.0', ['电子产品']),
      new Product(5, '第五个商品', 5.88, 1.5, 'angular4.0', ['图书']),
      new Product(6, '第六个商品', 6.88, 4.5, 'angular4.0', ['图书', '硬件设备'])
    ];
  }

}
// 因为我们是在用typescript在写程序，所以
// 需要用一个对象来封装所用到的产品信息
export class Product {
  // 首先定义一个product对象
  constructor(
    // 在Product的构造函数中声明产品所拥有
    // 的属性
    public id: number,
    public title: string,
    public price: number,
    public rating: number,
    public desc: string,
    public categories: Array<string>
    // string类型的数组
    // 这个类描述了我们产品所包含的信息
  ) {}
}
-------------------------------------------------------------------------------------------------------------------------
总结：
1、创建对象：因为是用typescript写的，所以对象的创建用class类。
在创建对象时直接作为constructor的参数定义。主意需要限定属性的类型：
export class Product {
  // 首先定义一个product对象
  constructor(
    // 在Product的构造函数中声明产品所拥有
    // 的属性
    public id: number,
    public title: string,
    public price: number,
    public rating: number,
    public desc: string,
    public categories: Array<string>
    // string类型的数组
    // 这个类描述了我们产品所包含的信息
  ) {}
}
2、使用对象
 products: Array<Product>;
  // 在定义完产品信息之后我们需要在ProductComponent
//   控制器中去声明一个数组，来存储页面上将要
//   展示的产品的数据
//  该数组是一个受Product格式限制的数组
3、初始化数组
this.products = [
      new Product(1, '第一个商品', 1.88, 3.5, 'angular4.0', ['图书', '硬件设备']),
      new Product(2, '第二个商品', 2.88, 2.5, 'angular4.0', ['电子产品', '硬件设备']),
      new Product(3, '第三个商品', 3.88, 4.5, 'angular4.0', ['硬件设备']),
      new Product(4, '第四个商品', 4.88, 2.5, 'angular4.0', ['电子产品']),
      new Product(5, '第五个商品', 5.88, 1.5, 'angular4.0', ['图书']),
      new Product(6, '第六个商品', 6.88, 4.5, 'angular4.0', ['图书', '硬件设备'])
    ];
-------------------------------------------------------------------------------------------------------------------------------

2.4、评级组件
