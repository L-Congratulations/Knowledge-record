一、angular4程序架构:
1.1、user<-->angular App <--> server
用户与angular App进行交互，然后angular App 与server进行交互
每个App至少要包含一个模块 NgModule（app就是由模块构成的），每个模块中有若干组件Component构成（模块就是由组件构成）component
1.1.1、组件
是angular应用的基本构建块，组件直接有父子关系。
组件可以调用服务
服务：是用来封装可重用的业务逻辑。比如获取商品信息的逻辑。在不同的组件间进行调用。服务之间也可以互相调用
指令：指令也是重要组成部分，指令允许你向html元素添加自定义行为
模块：用来将应用中不同的部分组成angular框架可以理解的单元

组件、服务、指令是用来完成功能的。
模块是用来打包分发功能的

1.2、ng-cli创建的目录分析
e2e：端到端测试，用来做自动化测试的
src：应用的源代码目录
angular-cli.json:angular命令行工具的配置文件，实战中会去修改这个文件，比如引入第三方的包的时候
package.json：npm命令工具配置文件
tslint.json：tslint的配置文件，做代码规则检测的 
src/environments：环境配置，可以在不同的环境（开发环境、生产环境、测试环境）开发。比如开发环境和生产环境的后台地址是不一样的
就需要在这里进行配置
src/polyfills.ts:使angular能够正常的运行在老的浏览器 
src/tsconfig.json:是typescript编译器的配置文件，已经配好，基本不用修改

1.3、关键文件的代码分析

1.3.1、组件：app.component.ts
与组件相关的基本概念：
（1）@Component（）装饰器
用来告知angular框架如何处理一个typescript的类。component包含多个属性，这些属性
的值叫做元数据。angular会根据这些元数据的值来渲染组件并执行组件的逻辑
（2）Template 模板
我们可以在模板中使用angular的数据绑定语法，来呈现控制器中的数据
（3）Controller控制器
就是一个普通的typescript类，他会被Component装饰器来装饰。控制器会包含组件所有的
属性和方法，绝大多数页面逻辑都是写在控制器里的。控制器通过数据绑定与模板（template）
进行通信，模板（template）展示控制器（Controller）的数据。控制器处理模板
（template）上发生的事件。
以上三点是组件的必备元素。
import { Component } from '@angular/core';
// 从angular的核心模块中引入了component装饰器

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
// 用装饰器定义了一个组件 以及组件的元数据
// 所有组件都必须使用一个component装饰器来注解
// （前边带有@的是装饰器）

export class AppComponent {
  // AppComponent是一个标准的typescript类
  // 要告诉angular AppComponent是一个组件需要把
  // 一些元数据附加到这个类上。在typescript中我们使用装饰器来附加元数据
  // 通过@Component把一些元数据加到 AppComponent类上
  // angular就会知道需要把AppComponent变成angular框架
  // 的一个组件
  // 元数据会告诉angular如何将AppComponent处理成一个组件

  // AppComponent这个typescript类定义了这个组件的控制器
  // 数据绑定是让模板的各个部分与控制器的各个部分相互作用的一个机制
  
  title = 'app';
}
（4）、非必备要素：
可选的可注入对象：属性输入@Inputs（）、提供器providers（用来做依赖注入的）、声明周期钩子
可选的输出对象：生命周期钩子、样式表、动画、输出属性@Outputs（）

1.3.2、模块app.module.ts
模块也是由装饰器修饰的typescript类

import { BrowserModule } from '@angular/platform-browser';

import { NgModule } from '@angular/core';

import { AppComponent } from './app.component';

@NgModule({
  declarations: [
    // declarations声明了模块中有什么东西，在这只声明
    // 了一个组件AppComponent。
    // 注意在这个属性中只能声明组件、指令和管道
    AppComponent
  ],
  imports: [
    // 声明了模块要正常运转还需要什么东西。也就是AppModule
    // 模块需要依赖的其他模块。在这声明了一个angular框架
    // 提供的模块BrowserModule（是开发web应用的必选依赖）
    // 还有FormsModule（处理表单的模块）、HttpModule等
    // （提供http服务的模块）等肯能用到的模块
    // 当把模块引入之后就可以在应用中使用这些模块所提供的
    // 组件、指令、服务等
    BrowserModule
  ],
  providers: [],
  // providers默认是空的。用来声明模块中提供了什么服务
  // 依赖注入的时候使用。这里只能声明服务。服务只能声明在
  // 这里
  bootstrap: [AppComponent]
  // bootstrap声明了模块的主组件是什么
})
export class AppModule { }

1.4、angular启动过程
启动的配置在angular-cli.json文件中
src/main.ts是整个应用启动的入口，整个应用的起点是从
platformBrowserDynamic().bootstrapModule(AppModule);开始运行的，
加载AppModule模块，首先分析app.module.ts(是AppModule对应的那个主模块)
需要依赖哪些模块（比如BrowserModule模块），把依赖的那些模块加载了之后再
分析那些模块需要什么模块，直到加载完所有所需的依赖。加载完之后会去index.html
中寻找<app-root></app-root>标签并把app.component.ts中装饰器中templateUrl
所指定的'./app.component.html'内容替换掉app-root标签。在替换的过程中主页面
会显示<app-root>Loading。。。</app-root>中的内容（loading。。。）

二、auction第一个版本
2.1、设置依赖
在项目中会用到jQuery和bootstrap等第三方的库，所以在开发前需要把库引入到我们的项目中：
（1）、将第三方库安装到本地
在auction项目目录下：npm install jquery --save(--save是为了吧jQuery记入到package.json文件中)
npm install bootstrap --save
（2）、把库引入到项目中
需要修改angular-cli.json文件。在文件中添加：
"styles": [
        "styles.css",
        "../node_modules/bootstrap/dist/css/bootstrap.css"
      ],
"scripts": [
  "../node_modules/jquery/dist/jquery.js",
  "../node_modules/bootstrap/dist/js/bootstrap.js"
],

（3）、因为jQuery是JavaScript的东西，typescript是不能直接使用的。需要安装jQuery和bootstrap的类型描述文件才能在typescript中正常使用
npm install @types/jquery --save-dev（不加dev放在package.json 的dependencies里面 ,加dev放在package.json的 devDependencies里面）
npm install @types/bootstrap --save-dev
安装完成。

2.2、angular开发思路：
在angular框架设计目标中最主要的目标之一就是方便开发人员开发出可重用的组件。很多特性都是为这个服务的。
开发的时候要用一种组件化的思路来思考我们要解决的问题。
将auction应用模块分成七个组件进行开发：navbar、footer、search、carousel、product、stars

2.2.1、es6 class类知识点补充
//定义类
class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  toString() {
    return '(' + this.x + ', ' + this.y + ')';
  }
}
上面代码定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象
Point类除了构造方法，还定义了一个toString方法。注意，定义“类”的方法的时候，前面不需要加上function这个关键字，
直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。
constructor方法是类的默认方法
constructor方法默认返回实例对象（即this）
与 ES5 一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class.proterty上）。
//定义类
class Point {

  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  toString() {
    return '(' + this.x + ', ' + this.y + ')';
  }

}

var point = new Point(2, 3);

point.toString() // (2, 3)

point.hasOwnProperty('x') // true
point.hasOwnProperty('y') // true
point.hasOwnProperty('toString') // false
point.__proto__.hasOwnProperty('toString') // true
上面代码中，x和y都是实例对象point自身的属性（因为定义在this变量上），所以hasOwnProperty方法返回true，
而toString是原型对象的属性（因为定义在Point类上），所以hasOwnProperty方法返回false。这些都与 ES5 的行为保持一致。

与 ES5 一样，类的所有实例共享一个原型对象。

var p1 = new Point(2,3);
var p2 = new Point(3,2);

p1.__proto__ === p2.__proto__
//true
上面代码中，p1和p2都是Point的实例，它们的原型都是Point.prototype，所以__proto__属性是相等的。

这也意味着，可以通过实例的__proto__属性为“类”添加方法。

__proto__ 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的JS引擎中都提供了这个私有属性
，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 Object.getPrototypeOf 方法来获取实例对象的原型，
然后再来为原型添加方法/属性。

var p1 = new Point(2,3);
var p2 = new Point(3,2);

p1.__proto__.printName = function () { return 'Oops' };

p1.printName() // "Oops"
p2.printName() // "Oops"

var p3 = new Point(4,2);
p3.printName() // "Oops"
上面代码在p1的原型上添加了一个printName方法，由于p1的原型就是p2的原型，因此p2也可以调用这个方法。
而且，此后新建的实例p3也可以调用这个方法。这意味着，使用实例的__proto__属性改写原型，必须相当谨慎，
不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。
--------------------------------------------------------------------------------------------------------------------------------
总结：在es6 的class类中
class Point {

  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  toString() {
    return '(' + this.x + ', ' + this.y + ')';
  }

}

var point = new Point(2, 3);

point.toString() // (2, 3)

point.hasOwnProperty('x') // true
point.hasOwnProperty('y') // true
point.hasOwnProperty('toString') // false
point.__proto__.hasOwnProperty('toString') // true
在constructor里面定义的x和y都是(class类自身的属性)实例对象point自身的属性（因为定义在this变量上），所以hasOwnProperty方法返回true，
在constructor外面定义的toString是class类原型对象的属性（因为定义在Point类上），所以hasOwnProperty方法返回false。
类的所有实例共享一个原型对象。
区分：一个是类自己的，一个是类原型上的。
-----------------------------------------------------------------------------------------------------------------------------

2.2.2、typescript中的类
extends 继承时的父类
private 装载私有属性，里面定义的成员外部不可使用且不能继承给子类，当成员被标记成private时，它就不能在声明它的类的外部访问。
protected 装载保护属性，里面定义的成员外部不可使用但可以继承给子类
public 装载公有属性默认为public
static 装载静态方法和属性
class Animal {
    private name: string;
    constructor(theName: string) { this.name = theName; }
}

new Animal("Cat").name; // Error: 'name' is private;


2.3、在typescript中创建产品数据
首先在typescript中定义一个对象来封装产品信息，并做格式限制。
然后在组件的controller中定义一个数组用来存储需要展现的产品信息
最后在ngOnInit生命周期钩子中初始化数组。
完整代码如下：
export class ProductComponent implements OnInit {
  private products: Array<Product>;
  // 在定义完产品信息之后我们需要在ProductComponent
//   控制器中去声明一个数组，来存储页面上将要
//   展示的产品的数据
//  该数组是一个受Product格式限制的数组
  constructor() { }

  ngOnInit() {
    // ngOnInit声明周期钩子，会在组件实例化
    // 之后调用一次
    this.products = [
      new Product(1, '第一个商品', 1.88, 3.5, 'angular4.0', ['图书', '硬件设备']),
      new Product(2, '第二个商品', 2.88, 2.5, 'angular4.0', ['电子产品', '硬件设备']),
      new Product(3, '第三个商品', 3.88, 4.5, 'angular4.0', ['硬件设备']),
      new Product(4, '第四个商品', 4.88, 2.5, 'angular4.0', ['电子产品']),
      new Product(5, '第五个商品', 5.88, 1.5, 'angular4.0', ['图书']),
      new Product(6, '第六个商品', 6.88, 4.5, 'angular4.0', ['图书', '硬件设备'])
    ];
  }

}
// 因为我们是在用typescript在写程序，所以
// 需要用一个对象来封装所用到的产品信息
export class Product {
  // 首先定义一个product对象
  constructor(
    // 在Product的构造函数中声明产品所拥有
    // 的属性
    public id: number,
    public title: string,
    public price: number,
    public rating: number,
    public desc: string,
    public categories: Array<string>
    // string类型的数组
    // 这个类描述了我们产品所包含的信息
  ) {}
}
-------------------------------------------------------------------------------------------------------------------------
总结：
1、创建对象：因为是用typescript写的，所以对象的创建用class类。
在创建对象时直接作为constructor的参数定义。主意需要限定属性的类型：
export class Product {
  // 首先定义一个product对象
  constructor(
    // 在Product的构造函数中声明产品所拥有
    // 的属性
    public id: number,
    public title: string,
    public price: number,
    public rating: number,
    public desc: string,
    public categories: Array<string>
    // string类型的数组
    // 这个类描述了我们产品所包含的信息
  ) {}
}
2、使用对象
 products: Array<Product>;
  // 在定义完产品信息之后我们需要在ProductComponent
//   控制器中去声明一个数组，来存储页面上将要
//   展示的产品的数据
//  该数组是一个受Product格式限制的数组
3、初始化数组
this.products = [
      new Product(1, '第一个商品', 1.88, 3.5, 'angular4.0', ['图书', '硬件设备']),
      new Product(2, '第二个商品', 2.88, 2.5, 'angular4.0', ['电子产品', '硬件设备']),
      new Product(3, '第三个商品', 3.88, 4.5, 'angular4.0', ['硬件设备']),
      new Product(4, '第四个商品', 4.88, 2.5, 'angular4.0', ['电子产品']),
      new Product(5, '第五个商品', 5.88, 1.5, 'angular4.0', ['图书']),
      new Product(6, '第六个商品', 6.88, 4.5, 'angular4.0', ['图书', '硬件设备'])
    ];
-------------------------------------------------------------------------------------------------------------------------------

2.4、评级组件

2.4.1、ng4的属性绑定：
使用[属性]=“值”进行属性绑定(属性如果不加[],那么就直接是传统的赋值，加上[]就是angular中属性绑定)
<p>2.属性绑定:</p>
<img src="{{src}}"/>
<p>3.属性绑定:</p>
<img [src]="src"/>

2.4.2、样式绑定
1、基本HTML属性绑定
<td [attr.colspan]="表达式"></td>
2、css绑定
<div class="a" [class]="b"></div> //b会完全替代a
<div [class.a]="fn()"></div> //fn()返回true，false，如果true添加.a
<div [ngClass]="{a:isA,b:isB}"></div> //b会完全替代a
3、样式绑定
<button [style.color]="a?red:green">button</button>
<button [ngStyle]="{'font-style':a?'red':'green'}">button</button>

2.4.3、编写评级组件

star.html:
<span *ngFor="let star of stars" class="glyphicon glyphicon-star"
  [class.glyphicon-star-empty]="star"></span>
  <span>{{rating}}</span>
</span>
star.js
export class StarsComponent implements OnInit {
  stars: boolean[];
  @Input() rating: number;
  constructor() { }

  ngOnInit() {
    this.stars = [];
    for (let i = 1; i <= 5 ; i++) {
      this.stars.push(i > this.rating);
    }
  }

}
---------------------------------------------------------------------------------------------------------------------
总结：
1、样式绑定：[class.glyphicon-star-empty]="star"意思是根据star的布尔值来判断是否将glyphicon-star-empty插入到class中。
2、 this.stars.push(i > this.rating);通过this.rating来拿到外边定义的值，使用 this.stars = [];来初始化数组
3、灵活使用push方法来创建数组this.stars.push(i > this.rating);
---------------------------------------------------------------------------------------------------------------------


三、路由
路由作用：改变页面内容。为每个视图提供一个唯一的url 以便用户可以根据URL跳转视图。
需要在同一个区域根据路由不同显示不同内容的时候，那这个区域要使用插座来满足需求。通过封装父组件的方式来控制该区域内有若干个子组件的要求。
在angular里主要提供了五个路由对象用来处理路由相关的功能：
Routes：是app-routring.module.ts中的配置对象，用来指明路由的path和component
RouterOutlet：在html中标记路由内容呈现位置的占位符指令。需要展现的内容会显示在RouterOutlet的后面<router-outlet></router-outlet>
Router：和RouterLink一样是用来导航到一个指定的路由。不同的是Router是在控制器里面用的的通过调方法来实现导航。RouterLink是直接写在html里导航
类比于a标签的作用。<a [routerLink]="['/']">主页</a>
ActivatedRouter:当前激活的路由对象，保存着当前路由的信息，如路由地址，
路由参数等
3.1、spa 主页面只加载一次，然后通过路由切换改变页面显示的内容
3.2、路由基础：
3.2.1、Routes：路由配置，保存着哪个URL对应展示哪个组件，以及在哪个RouterOutlet
中展示
就是在app-routing.module.ts里面的routes
里面是用来配置path和component的：
const routes: Routes = [
  { path: '', component: HomeComponent },
  { path: 'product', component: ProductComponent},
  { path: '**', component: Code404Component}
];
这里需要注意component后面的组件需要用import { HomeComponent } from './home/home.component';
引入
在路由的path参数中不能用斜线开头'/product'配置
3.2.2、

3.2.3、Router：负责在运行时执行路由的对象，可以通过调用其navgate（）和
navgateByUrl（）方法来导航到一个指定的路由
3.2.4、RouterLink：在html中声明路由导航用的指令
相当于a标签的href属性
<a [routerLink]="['/']">主页</a>
<a [routerLink]="['/product']">商品详情页</a>
注意在这写路径的时候需要用斜线开头['/product']，因为涉及到子路由的时候需要
用'././product'的方式来确定这个链接是导航到跟路由还是自路由。/开头就表示根路由
注意routerLink的参数是一个数组，因为我们可以在路由的时候传递一些参数
在传递参数的时候就可以直接在数组中添加参数的值

与他相同的另一种写法：（上边是在页面上的链接跳转的，这个是通过后台控制器
中调用router的方法实现的也就是3.2.3中的方法）
首先定义一个点击事件：<input type="button" value="商品详情" (click)="toProductDetails()">
然后在对应的.ts中添加如下代码：
constructor(private router: Router) {}
  toProductDetails() {
  this.router.navigate(['/product']);//这的参数和routerlingk的参数一样
  }
3.2.5、ActivatedRouter:当前激活的路由对象，保存着当前路由的信息，如路由地址，
路由参数等

3.2.6、在哪里使用了事件或属性就在对应组件的.ts文件中去定义

3.2.7、
const routes: Routes = [
  { path: '', component: HomeComponent },
  { path: 'product', component: ProductComponent},
  { path: '**', component: Code404Component}//当页面不存在时会展现404页面的内容
];

3.2.8、路由重定向
const routes: Routes = [
  { path: '', redirectTo: '/home', pathMatch: 'full' },
  { path: 'home', component: HomeComponent },
  { path: 'product', component: ProductComponent, canActivate: [LoginGuard]},
  { path: '**', component: Code404Component}
];
注意redirectTo的参数包含斜线/

3.2.9、路由传递参数
这里注意记录在查询参数中传递参数和路由路径中传递参数两种方法：
1、在查询参数中传递参数：
<a [routerLink]="['/product']" [queryParams]="{id: 1}">商品详情页</a>
此时点击链接之后就会看到网址变成了http://localhost:4200/product?id=1，此时已经在路由中传了参数
接收参数此时页面已经跳转到了详情页，因此要在详情页对应的.ts文件中接收参数：
export class ProductComponent implements OnInit {
  private productId: number;
  constructor(private routeInfo: ActivatedRoute) { }

  ngOnInit() {
    this.productId = this.routeInfo.snapshot.queryParams['id'];
  }

}先定义一个变量productId接收参数，然后在构造函数中注入routeInfo，最后在声明周期钩子中给productId赋值

2、在URL中传递参数
首先将路由配置文件中的path该成一个可以接受参数的路径path: 'product/:id'
然后将routerLink改为<a [routerLink]="['/product', 1]">商品详情页</a>
最后在取值的时候改为：
this.productId = this.routeInfo.queryParams['id'];
其他不变

参数订阅，为了更好的
在url中传参方法获取数据的时候使用参数订阅
this.routeInfo.params.subscribe((params: Params) => {this.productId = params['id']; });
3.2.11、路由守卫
场景：
1、只有当用户已经登录并拥有某些权限时才能进入某些路由
2、一个由多个表单组件组成的向导，例如注册流程，用户只有在当前路由的组件中
填写了满足要求的信息才可以导航到下一个路由
3、当用户未执行保存操作而试图离开当前导航时提醒用户
路由系统提供了一些钩子来控制进入离开路由。
在这介绍三种路由守卫：
1、CanActivate：处理导航到某路由情况。如果不满足则不能进入到指定路由
首先新建一个guard文件，在里面新建一个.ts文件
然后在ts文件里写：
import {CanActivate} from '@angular/router';
/**
 * Created by ls-pc on 2017/8/7.
 */
export class LoginGuard implements CanActivate {
  canActivate() {
    let logeIn: boolean = Math.random() > 0.5;
    if (!logeIn) {
      console.log('用户未登录');
    }
    return logeIn;//注意要从这个地方来返回true或者false
  }
}
在app.routing路由配置文件中：
const routes: Routes = [
  { path: '', redirectTo: '/home', pathMatch: 'full' },
  { path: 'home', component: HomeComponent },
  { path: 'product', component: ProductComponent, canActivate: [LoginGuard]},
  { path: '**', component: Code404Component}
];
在有权限的路由上加上canActivate: [LoginGuard] 然后一定要在修饰器中进行注册
@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule],
  providers: [LoginGuard]
})
2、CanDeactivate：处理从当前路由离开的情况。不满足则不能离开
3、Resolve：在路由激活之前获取路由数据



四、数据绑定
4.1、数据绑定允许你将组件控制器的方法和属性与组件的模板链接起来
大大降低了开发时的编码量
4.2、在angular中默认的数据绑定是以单向的方式实现的，所谓的单向是指，要么将组件控制器属性的变化反映到模板上。
要么将模板上的事件绑定到组件控制器的方法上。

4.3、几种数据绑定的形式
1、事件绑定
<input (input)="onInputEvent($event)">
  小括号代表这是一个事件绑定，括号内的是事件名称
  当小括号内指定的事件触发时，会调用等号右侧的方法。
  如果处理事件的方法需要了解事件的属性，可以给方法
  内添加一个$event参数
  等号右边的不仅仅可以是函数调用，也可以是一个属性赋值
  如：<button (click)="save = true"></button>
  被绑定的事件也可以是自定义事件
2、dom属性绑定
插值表达式和属性绑定是一个东西：
 <img src="{{imgUrl}}" alt="">
  <img [src]="imgUrl" alt="">
  是一样的
html属性和dom属性的区别：
html属性指定了初始值，dom属性表示当前值
html属性初始了dom属性，然后他的任务就完成了

angular模板绑定是通过dom属性和事件来工作的，而不是HTML属性
3、html属性绑定
css类绑定：
<div class="aa bb" [class]="someExpression"></div>后边的值会覆盖掉前边class的值
<div [class.special]="isSpcial"></div>special类会根据后边参数的布尔值来决定是否添加到div中
<div [ngClass]="{aaa:isA, bbb:isB}"></div>控制多个class类是否添加到div中
样式绑定：和css类绑定类似
4、双向绑定

八、与服务器通信
angular的http服务：
dataResource: Observable<any>; // 用来接收http返回来的数据
  products: Array<any> = []; // 与html模板进行绑定
  constructor(private http: Http) {
    this.dataResource = this.http.get('/products') //在这的get只是订阅了请求并没有发送，发送请求是在 this.dataResource.subscribe发送的
      .map((res) => res.json()); // 调用map方法需要引入import 'rxjs/Rx';
  }

  ngOnInit() {
    this.dataResource.subscribe( // 通过调用subscribe来订阅一个流
      (data) => this.products = data
    );
  }
配置angular命令行告诉他服务发往的位置。
  首先编写一个配置文件：在根目录下新建proxy.conf.json在里面编写
  {"/api":{
         "target":"http://localhost:8000" // 也就是当我请求的路径是/api开头的时候他会把请求转发到8000这个服务器上
         }}
         有了这个配置文件之后需要告诉angular服务在启动的时候加上这个配置文件。打开packag.json在start配置项中添加：
         "start": "ng serve --proxy-config proxy.conf.json",
  配置好之后需要修改请求路径： this.dataResource = this.http.get('/api/products'),当然对应的服务端的地址也应该改为app.get("/api/products")
  
  发送请求头信息：
   constructor(private http: Http) {
    const myHeaders: Headers = new Headers();
    myHeaders.append('Authorization', 'Basic 123456');
    this.dataResource = this.http.get('/api/products', {headers: myHeaders})
      .map((res) => res.json()); // 调用map方法需要引入import 'rxjs/Rx';
  }
  
  
  websocket通信：是一个长连接协议，不需要每次发送信息时都重新进行连接
  在node.js中我们使用ws。首先安装ws的依赖库和类型定义文件npm i ws --save 然后安装ws的类型定义文件：npm i @types/ws --save-dev
  
8.1、如何使用angular的API与服务器进行通信
8.2、如何使用angular的http服务，创建并发送http请求。并且响应式的处理服务器端的返回
8.3、如何通过websocke协议来与服务器通讯。在这主要学习如何从服务器向客户端推送数据
8.4、创建web服务器
8.4.1、使用node.js创建一个简单的服务器
8.4.1.1、首先新建一个新的文件夹server 并用npm初始化 npm init -y （-y参数会为我们创建一个包含默认配置的packge.json文件）
8.4.1.2、我们使用typescript语言来开发我们的服务器。首先我们需要引入node的类型定义文件npm i @types/node --save
类型文件的作用是为了让开发者在使用typescript开发中可以使用已有的js写成的库
node本身是不认识typescript的，所以我们需要将typescript编译成JavaScript。我们需要写个配置文件tsconfig.json来告诉编译器如何将
typescript编译成JavaScript内容如下：
{
  "compilerOptions": {
    "module": "commonjs",
    "target": "es5",
    "sourceMap": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "outDir": "build",
    "lib": ["es6"]
  },
  "exclude": [
    "node_modules"
  ]
}
再创建一个文件夹server
为了减少开发的代码量，需要引入express框架：npm i express --save
和node一样，我们也需要转express的类型定义文件以便我们可以使用typescript来开发 npm i @types/express --save
然后安装一个node工具，npm i -g -nodemon 这个工具会监控node代码，当代码改变时会自动重启服务运行最新的代码
之后启动服务器用nodemon build/auction_server.js来启动服务
8.4.2、使用express创建restful的http服务
8.4.3、如何健康服务器文件的变化
8.4.4、angular的http服务
默认的情况下，angular的http服务采用响应式编程的方式来处理http请求
在web中应该异步的去执行http请求，
九、代码构建部署
构建直接：ng build就能满足要求
部署：在nodejs编写的服务器里面新建一个文件夹client。然后将ng build打包出来的代码拷贝进去。然后将读取的文件地址改为我们创建的client里面
的index
此时页面不能刷新，要想能实现刷新，需要在 app.module.ts里面的providers里面添加一个{provide: .....}重新编译

十、组件间通信

黑盒模型：只需要了解接收到什么参数之后返回什么结果。

10.1、输入属性：@Input() 注意双方链接的桥梁是<app-first-child [pname]="sex"></app-first-child> 属性绑定是单向的，从父组件到子组件也就是子组件元素变化
不会影响到父组件  只能是父子组件之间进行数据传递
父组件html：
<p>
  first works!{{name}}
  <input type="text" [(ngModel)]="name"> // 双向数据绑定到name
  <app-first-child [pname]="name"></app-first-child>
  <!--[pname]是在子组件中通过@input属性定义的一个存储变量pname-->
  <!--"sex"对应父组件中定义的变量名，想给pname传什么值就对应将变量名填入-->
  <!--这是链接父子组件的桥梁pname对应着子组件的变量 sex对应着父组件的变量-->
</p>
父组件js：
export class FirstComponent implements OnInit {
  sex: string;
  name = ' ';

  constructor() {
    this.name = 'parentName';
    this.sex = '女';
  }

  ngOnInit() {
  }

}
10.2、输出属性
注意：用特定的数据结构用类或接口来明确定义是一个很好的习惯
子组件js:EventEmitter这个类有多个声明，要选择angular/core这个里面的声明。他需要一个泛型如<number>
用 @Output()注解之后在构造函数里面emit发射事件： this.change.emit(this.count);    // 在increaseNumber和descreaseNumber方法修改了count属性后，
调用了change属性的emit方法通知父组件
export class FirstChildComponent implements OnInit { 
  @Output() change = new EventEmitter<number>();
  // 使用装饰器@Output修饰了change属性，并为其赋了初值为EventEmitter的实例；
  // count = 0; count变量可以直接在本地定义也可以从父组件获取
  @Input() count: number;  
  constructor() {}
  increaseNum() {
    this.count ++;
    this.change.emit(this.count);
    // 在increaseNumber和descreaseNumber方法修改了count属性后，
    // 调用了change属性的emit方法通知父组件。
  }
  descreaseNum() {
    this.count --;
    this.change.emit(this.count);
  }
  ngOnInit() {
  }

}
子组件html：
<p>
  Count:{{count}}
  <!--{{name}}{{pname}}依旧只是对应着该组件中的name pname变量-->
</p>
<button (click)="increaseNum()">+</button>
<button (click)="descreaseNum()">-</button>
父组件js：
export class FirstComponent implements OnInit { 
  caseCount = 10;
  // 定义并初始化一个变量用来接收从子组件传递过来的数据
  constructor() {    
  }
  countChange($event) {
    // 通过桥梁与子组件的chang建立联系，并把值此处的$event就相当于
    // this.change.emit(this.count);中的this.count 并把传递过来的值保存到本组件中
    this.caseCount = $event;
  }
  ngOnInit() {
  }

}
父组件html：
<p>
  parentNum{{caseCount}}
  <app-first-child [count]="caseCount" (change)="countChange($event)"></app-first-child>
  <!--通过(change)="countChange($event)"把子组件的chang与父组件的countChange进行桥梁链接
  $event接收的就是传递的数据--> 
</p>
-----------------------------------------------------------------------------------------------------------------------
父组件监听子组件变化（子组件传递数据给父组件）：
1、首先在子组件中借助@Output    change = new EventEmitter();初始化一个chang属性
2、然后建立一个触发事件 
increaseNum() {
    this.count ++;
    this.change.emit(this.count);
    // 在increaseNumber和descreaseNumber方法修改了count属性后，
    // 调用了change属性的emit方法通知父组件。
 }
通过chang属性的emit方法把想要传递的数据告诉父组件
3、子组件父组件通过
<app-first-child (change)="countChange($event)"></app-first-child>
建立桥梁连接 此时父组件的countChange方法会接收到子组件传递的数据，数据就存储在$event参数中
4、在父组件中处理取到的子组件数据
caseCount = 10;  // 定义并初始化一个变量用来接收从子组件传递过来的数据
countChange($event) {
    // 通过桥梁与子组件的chang建立联系，并把值此处的$event就相当于
    // this.change.emit(this.count);中的this.count 并把传递过来的值保存到本组件中
    this.caseCount = $event;
  }
10.3、中间人模式（非父子组件之间的信息传递）
